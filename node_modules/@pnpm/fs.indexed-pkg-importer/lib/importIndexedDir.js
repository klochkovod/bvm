"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importIndexedDir = void 0;
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const logger_1 = require("@pnpm/logger");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const sanitize_filename_1 = __importDefault(require("sanitize-filename"));
const make_empty_dir_1 = __importDefault(require("make-empty-dir"));
const path_temp_1 = __importDefault(require("path-temp"));
const rename_overwrite_1 = __importDefault(require("rename-overwrite"));
const filenameConflictsLogger = (0, logger_1.logger)('_filename-conflicts');
async function importIndexedDir(importFile, newDir, filenames, opts) {
    const stage = (0, path_temp_1.default)(path_1.default.dirname(newDir));
    try {
        await tryImportIndexedDir(importFile, stage, filenames);
        if (opts.keepModulesDir) {
            // Keeping node_modules is needed only when the hoisted node linker is used.
            await moveOrMergeModulesDirs(path_1.default.join(newDir, 'node_modules'), path_1.default.join(stage, 'node_modules'));
        }
        await (0, rename_overwrite_1.default)(stage, newDir);
    }
    catch (err) { // eslint-disable-line
        try {
            await (0, rimraf_1.default)(stage);
        }
        catch (err) { } // eslint-disable-line:no-empty
        if (err['code'] === 'EEXIST') {
            const { uniqueFileMap, conflictingFileNames } = getUniqueFileMap(filenames);
            if (Object.keys(conflictingFileNames).length === 0)
                throw err;
            filenameConflictsLogger.debug({
                conflicts: conflictingFileNames,
                writingTo: newDir,
            });
            (0, logger_1.globalWarn)(`Not all files were linked to "${path_1.default.relative(process.cwd(), newDir)}". ` +
                'Some of the files have equal names in different case, ' +
                'which is an issue on case-insensitive filesystems. ' +
                `The conflicting file names are: ${JSON.stringify(conflictingFileNames)}`);
            await importIndexedDir(importFile, newDir, uniqueFileMap, opts);
            return;
        }
        if (err['code'] === 'ENOENT') {
            const { sanitizedFilenames, invalidFilenames } = sanitizeFilenames(filenames);
            if (invalidFilenames.length === 0)
                throw err;
            (0, logger_1.globalWarn)(`\
The package linked to "${path_1.default.relative(process.cwd(), newDir)}" had \
files with invalid names: ${invalidFilenames.join(', ')}. \
They were renamed.`);
            await importIndexedDir(importFile, newDir, sanitizedFilenames, opts);
            return;
        }
        throw err;
    }
}
exports.importIndexedDir = importIndexedDir;
function sanitizeFilenames(filenames) {
    const sanitizedFilenames = {};
    const invalidFilenames = [];
    for (const [filename, src] of Object.entries(filenames)) {
        const sanitizedFilename = filename.split('/').map((f) => (0, sanitize_filename_1.default)(f)).join('/');
        if (sanitizedFilename !== filename) {
            invalidFilenames.push(filename);
        }
        sanitizedFilenames[sanitizedFilename] = src;
    }
    return { sanitizedFilenames, invalidFilenames };
}
async function tryImportIndexedDir(importFile, newDir, filenames) {
    await (0, make_empty_dir_1.default)(newDir, { recursive: true });
    const alldirs = new Set();
    Object.keys(filenames)
        .forEach((f) => {
        const dir = path_1.default.dirname(f);
        if (dir === '.')
            return;
        alldirs.add(dir);
    });
    await Promise.all(Array.from(alldirs)
        .sort((d1, d2) => d1.length - d2.length) // from shortest to longest
        .map(async (dir) => fs_1.promises.mkdir(path_1.default.join(newDir, dir), { recursive: true })));
    await Promise.all(Object.entries(filenames)
        .map(async ([f, src]) => {
        const dest = path_1.default.join(newDir, f);
        await importFile(src, dest);
    }));
}
function getUniqueFileMap(fileMap) {
    const lowercaseFiles = new Map();
    const conflictingFileNames = {};
    const uniqueFileMap = {};
    for (const filename of Object.keys(fileMap).sort()) {
        const lowercaseFilename = filename.toLowerCase();
        if (lowercaseFiles.has(lowercaseFilename)) {
            conflictingFileNames[filename] = lowercaseFiles.get(lowercaseFilename);
            continue;
        }
        lowercaseFiles.set(lowercaseFilename, filename);
        uniqueFileMap[filename] = fileMap[filename];
    }
    return {
        conflictingFileNames,
        uniqueFileMap,
    };
}
async function moveOrMergeModulesDirs(src, dest) {
    try {
        await renameEvenAcrossDevices(src, dest);
    }
    catch (err) { // eslint-disable-line
        switch (err.code) {
            case 'ENOENT':
                // If src directory doesn't exist, there is nothing to do
                return;
            case 'ENOTEMPTY':
            case 'EPERM': // This error code is thrown on Windows
                // The newly added dependency might have node_modules if it has bundled dependencies.
                await mergeModulesDirs(src, dest);
                return;
            default:
                throw err;
        }
    }
}
async function renameEvenAcrossDevices(src, dest) {
    try {
        await fs_1.promises.rename(src, dest);
    }
    catch (err) { // eslint-disable-line
        if (err.code !== 'EXDEV')
            throw err;
        await (0, fs_extra_1.copy)(src, dest);
    }
}
async function mergeModulesDirs(src, dest) {
    const srcFiles = await fs_1.promises.readdir(src);
    const destFiles = new Set(await fs_1.promises.readdir(dest));
    const filesToMove = srcFiles.filter((file) => !destFiles.has(file));
    await Promise.all(filesToMove.map((file) => renameEvenAcrossDevices(path_1.default.join(src, file), path_1.default.join(dest, file))));
}
//# sourceMappingURL=importIndexedDir.js.map