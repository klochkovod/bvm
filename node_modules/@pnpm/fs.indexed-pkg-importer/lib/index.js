"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyPkg = exports.createIndexedPkgImporter = void 0;
const fs_1 = require("fs");
const graceful_fs_1 = __importDefault(require("@pnpm/graceful-fs"));
const path_1 = __importDefault(require("path"));
const logger_1 = require("@pnpm/logger");
const core_loggers_1 = require("@pnpm/core-loggers");
const p_limit_1 = __importDefault(require("p-limit"));
const path_exists_1 = __importDefault(require("path-exists"));
const importIndexedDir_1 = require("./importIndexedDir");
const limitLinking = (0, p_limit_1.default)(16);
function createIndexedPkgImporter(packageImportMethod) {
    const importPackage = createImportPackage(packageImportMethod);
    return async (to, opts) => limitLinking(async () => importPackage(to, opts));
}
exports.createIndexedPkgImporter = createIndexedPkgImporter;
function createImportPackage(packageImportMethod) {
    // this works in the following way:
    // - hardlink: hardlink the packages, no fallback
    // - clone: clone the packages, no fallback
    // - auto: try to clone or hardlink the packages, if it fails, fallback to copy
    // - copy: copy the packages, do not try to link them first
    switch (packageImportMethod ?? 'auto') {
        case 'clone':
            core_loggers_1.packageImportMethodLogger.debug({ method: 'clone' });
            return clonePkg;
        case 'hardlink':
            core_loggers_1.packageImportMethodLogger.debug({ method: 'hardlink' });
            return hardlinkPkg.bind(null, linkOrCopy);
        case 'auto': {
            return createAutoImporter();
        }
        case 'clone-or-copy':
            return createCloneOrCopyImporter();
        case 'copy':
            core_loggers_1.packageImportMethodLogger.debug({ method: 'copy' });
            return copyPkg;
        default:
            throw new Error(`Unknown package import method ${packageImportMethod}`);
    }
}
function createAutoImporter() {
    let auto = initialAuto;
    return async (to, opts) => auto(to, opts);
    async function initialAuto(to, opts) {
        try {
            if (!await clonePkg(to, opts))
                return undefined;
            core_loggers_1.packageImportMethodLogger.debug({ method: 'clone' });
            auto = clonePkg;
            return 'clone';
        }
        catch (err) { // eslint-disable-line
            // ignore
        }
        try {
            if (!await hardlinkPkg(graceful_fs_1.default.link, to, opts))
                return undefined;
            core_loggers_1.packageImportMethodLogger.debug({ method: 'hardlink' });
            auto = hardlinkPkg.bind(null, linkOrCopy);
            return 'hardlink';
        }
        catch (err) { // eslint-disable-line
            if (err.message.startsWith('EXDEV: cross-device link not permitted')) {
                (0, logger_1.globalWarn)(err.message);
                (0, logger_1.globalInfo)('Falling back to copying packages from store');
                core_loggers_1.packageImportMethodLogger.debug({ method: 'copy' });
                auto = copyPkg;
                return auto(to, opts);
            }
            // We still choose hard linking that will fall back to copying in edge cases.
            core_loggers_1.packageImportMethodLogger.debug({ method: 'hardlink' });
            auto = hardlinkPkg.bind(null, linkOrCopy);
            return auto(to, opts);
        }
    }
}
function createCloneOrCopyImporter() {
    let auto = initialAuto;
    return async (to, opts) => auto(to, opts);
    async function initialAuto(to, opts) {
        try {
            if (!await clonePkg(to, opts))
                return undefined;
            core_loggers_1.packageImportMethodLogger.debug({ method: 'clone' });
            auto = clonePkg;
            return 'clone';
        }
        catch (err) { // eslint-disable-line
            // ignore
        }
        core_loggers_1.packageImportMethodLogger.debug({ method: 'copy' });
        auto = copyPkg;
        return auto(to, opts);
    }
}
async function clonePkg(to, opts) {
    const pkgJsonPath = path_1.default.join(to, 'package.json');
    if (!opts.fromStore || opts.force || !await (0, path_exists_1.default)(pkgJsonPath)) {
        await (0, importIndexedDir_1.importIndexedDir)(cloneFile, to, opts.filesMap, opts);
        return 'clone';
    }
    return undefined;
}
async function cloneFile(from, to) {
    await graceful_fs_1.default.copyFile(from, to, fs_1.constants.COPYFILE_FICLONE_FORCE);
}
async function hardlinkPkg(importFile, to, opts) {
    if (!opts.fromStore ||
        opts.force ||
        !await pkgLinkedToStore(opts.filesMap, to)) {
        await (0, importIndexedDir_1.importIndexedDir)(importFile, to, opts.filesMap, opts);
        return 'hardlink';
    }
    return undefined;
}
async function linkOrCopy(existingPath, newPath) {
    try {
        await graceful_fs_1.default.link(existingPath, newPath);
    }
    catch (err) { // eslint-disable-line
        // If a hard link to the same file already exists
        // then trying to copy it will make an empty file from it.
        if (err['code'] === 'EEXIST')
            return;
        // In some VERY rare cases (1 in a thousand), hard-link creation fails on Windows.
        // In that case, we just fall back to copying.
        // This issue is reproducible with "pnpm add @material-ui/icons@4.9.1"
        await graceful_fs_1.default.copyFile(existingPath, newPath);
    }
}
async function pkgLinkedToStore(filesMap, to) {
    if (filesMap['package.json']) {
        if (await isSameFile('package.json', to, filesMap)) {
            return true;
        }
    }
    else {
        // An injected package might not have a package.json.
        // This will probably only even happen in a Bit workspace.
        const [anyFile] = Object.keys(filesMap);
        if (await isSameFile(anyFile, to, filesMap))
            return true;
    }
    return false;
}
async function isSameFile(filename, linkedPkgDir, filesMap) {
    const linkedFile = path_1.default.join(linkedPkgDir, filename);
    let stats0;
    try {
        stats0 = await graceful_fs_1.default.stat(linkedFile);
    }
    catch (err) { // eslint-disable-line
        if (err.code === 'ENOENT')
            return false;
    }
    const stats1 = await graceful_fs_1.default.stat(filesMap[filename]);
    if (stats0.ino === stats1.ino)
        return true;
    (0, logger_1.globalInfo)(`Relinking ${linkedPkgDir} from the store`);
    return false;
}
async function copyPkg(to, opts) {
    const pkgJsonPath = path_1.default.join(to, 'package.json');
    if (!opts.fromStore || opts.force || !await (0, path_exists_1.default)(pkgJsonPath)) {
        await (0, importIndexedDir_1.importIndexedDir)(graceful_fs_1.default.copyFile, to, opts.filesMap, opts);
        return 'copy';
    }
    return undefined;
}
exports.copyPkg = copyPkg;
//# sourceMappingURL=index.js.map