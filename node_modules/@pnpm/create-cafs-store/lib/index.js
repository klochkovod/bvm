"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCafsStore = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const cafs_1 = require("@pnpm/cafs");
const fs_indexed_pkg_importer_1 = require("@pnpm/fs.indexed-pkg-importer");
const mem_1 = __importDefault(require("mem"));
const path_temp_1 = __importDefault(require("path-temp"));
const map_1 = __importDefault(require("ramda/src/map"));
function createPackageImporter(opts) {
    const cachedImporterCreator = opts.importIndexedPackage
        ? () => opts.importIndexedPackage
        : (0, mem_1.default)(fs_indexed_pkg_importer_1.createIndexedPkgImporter);
    const packageImportMethod = opts.packageImportMethod;
    const gfm = getFlatMap.bind(null, opts.cafsDir);
    return async (to, opts) => {
        const { filesMap, isBuilt } = gfm(opts.filesResponse, opts.sideEffectsCacheKey);
        const pkgImportMethod = (opts.requiresBuild && !isBuilt)
            ? 'clone-or-copy'
            : (opts.filesResponse.packageImportMethod ?? packageImportMethod);
        const impPkg = cachedImporterCreator(pkgImportMethod);
        const importMethod = await impPkg(to, {
            filesMap,
            fromStore: opts.filesResponse.fromStore,
            force: opts.force,
            keepModulesDir: Boolean(opts.keepModulesDir),
        });
        return { importMethod, isBuilt };
    };
}
function getFlatMap(cafsDir, filesResponse, targetEngine) {
    if (filesResponse.local) {
        return {
            filesMap: filesResponse.filesIndex,
            isBuilt: false,
        };
    }
    let isBuilt;
    let filesIndex;
    if (targetEngine && ((filesResponse.sideEffects?.[targetEngine]) != null)) {
        filesIndex = filesResponse.sideEffects?.[targetEngine];
        isBuilt = true;
    }
    else {
        filesIndex = filesResponse.filesIndex;
        isBuilt = false;
    }
    const filesMap = (0, map_1.default)(({ integrity, mode }) => (0, cafs_1.getFilePathByModeInCafs)(cafsDir, integrity, mode), filesIndex);
    return { filesMap, isBuilt };
}
function createCafsStore(storeDir, opts) {
    const cafsDir = path_1.default.join(storeDir, 'files');
    const baseTempDir = path_1.default.join(storeDir, 'tmp');
    const importPackage = createPackageImporter({
        importIndexedPackage: opts?.importPackage,
        packageImportMethod: opts?.packageImportMethod,
        cafsDir,
    });
    return {
        ...(0, cafs_1.createCafs)(cafsDir, opts?.ignoreFile),
        cafsDir,
        importPackage,
        tempDir: async () => {
            const tmpDir = (0, path_temp_1.default)(baseTempDir);
            await fs_1.promises.mkdir(tmpDir, { recursive: true });
            return tmpDir;
        },
    };
}
exports.createCafsStore = createCafsStore;
//# sourceMappingURL=index.js.map