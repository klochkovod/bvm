"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDirToWindowsEnvPath = void 0;
const error_1 = require("@pnpm/error");
const string_prototype_matchall_1 = __importDefault(require("string.prototype.matchall"));
const path_1 = require("path");
const safe_execa_1 = __importDefault(require("safe-execa"));
class BadEnvVariableError extends error_1.PnpmError {
    constructor({ envName, wantedValue, currentValue }) {
        super('BAD_ENV_FOUND', `Currently '${envName}' is set to '${wantedValue}'`);
        this.envName = envName;
        this.wantedValue = wantedValue;
        this.currentValue = currentValue;
    }
}
const REG_KEY = 'HKEY_CURRENT_USER\\Environment';
function addDirToWindowsEnvPath(dir, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // Use `chcp` to make `reg` use utf8 encoding for output.
        // Otherwise, the non-ascii characters in the environment variables will become garbled characters.
        const chcpResult = yield (0, safe_execa_1.default)('chcp');
        const cpMatch = (_a = /\d+/.exec(chcpResult.stdout)) !== null && _a !== void 0 ? _a : [];
        const cpBak = parseInt(cpMatch[0]);
        if (chcpResult.failed || !(cpBak > 0)) {
            throw new error_1.PnpmError('CHCP', `exec chcp failed: ${cpBak}, ${chcpResult.stderr}`);
        }
        yield (0, safe_execa_1.default)('chcp', ['65001']);
        try {
            const report = yield _addDirToWindowsEnvPath(dir, opts);
            yield refreshEnvVars();
            return report;
        }
        finally {
            yield (0, safe_execa_1.default)('chcp', [cpBak.toString()]);
        }
    });
}
exports.addDirToWindowsEnvPath = addDirToWindowsEnvPath;
function _addDirToWindowsEnvPath(dir, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const addedDir = path_1.win32.normalize(dir);
        const registryOutput = yield getRegistryOutput();
        const changes = [];
        if (opts.proxyVarName) {
            changes.push(yield updateEnvVariable(registryOutput, opts.proxyVarName, addedDir, {
                expandableString: false,
                overwrite: opts.overwriteProxyVar,
            }));
            changes.push(yield addToPath(registryOutput, `%${opts.proxyVarName}%`, opts.position));
        }
        else {
            changes.push(yield addToPath(registryOutput, addedDir, opts.position));
        }
        return changes;
    });
}
function updateEnvVariable(registryOutput, name, value, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const currentValue = yield getEnvValueFromRegistry(registryOutput, name);
        if (currentValue && !opts.overwrite) {
            if (currentValue !== value) {
                throw new BadEnvVariableError({ envName: name, currentValue, wantedValue: value });
            }
            return { variable: name, action: 'skipped', oldValue: currentValue, newValue: value };
        }
        else {
            yield setEnvVarInRegistry(name, value, { expandableString: opts.expandableString });
            return { variable: name, action: 'updated', oldValue: currentValue, newValue: value };
        }
    });
}
function addToPath(registryOutput, addedDir, position = 'start') {
    return __awaiter(this, void 0, void 0, function* () {
        const variable = 'Path';
        const pathData = yield getEnvValueFromRegistry(registryOutput, variable);
        if (pathData === undefined || pathData == null || pathData.trim() === '') {
            throw new error_1.PnpmError('NO_PATH', '"Path" environment variable is not found in the registry');
        }
        else if (pathData.split(path_1.win32.delimiter).includes(addedDir)) {
            return { action: 'skipped', variable, oldValue: pathData, newValue: pathData };
        }
        else {
            const newPathValue = position === 'start'
                ? `${addedDir}${path_1.win32.delimiter}${pathData}`
                : `${pathData}${path_1.win32.delimiter}${addedDir}`;
            yield setEnvVarInRegistry('Path', newPathValue, { expandableString: true });
            return { action: 'updated', variable, oldValue: pathData, newValue: newPathValue };
        }
    });
}
// `windowsHide` in `execa` is true by default, which will cause `chcp` to have no effect.
const EXEC_OPTS = { windowsHide: false };
/**
 * We read all the registry values and then pick the keys that we need.
 * This is done because if we would try to pick a key that is not in the registry, the command would fail.
 * And it is hard to identify the real cause of the command failure.
 */
function getRegistryOutput() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const queryResult = yield (0, safe_execa_1.default)('reg', ['query', REG_KEY], EXEC_OPTS);
            return queryResult.stdout;
        }
        catch (err) { // eslint-disable-line
            throw new error_1.PnpmError('REG_READ', 'win32 registry environment values could not be retrieved');
        }
    });
}
function getEnvValueFromRegistry(registryOutput, envVarName) {
    return __awaiter(this, void 0, void 0, function* () {
        const regexp = new RegExp(`^ {4}(?<name>${envVarName}) {4}(?<type>\\w+) {4}(?<data>.*)$`, 'gim');
        const match = Array.from((0, string_prototype_matchall_1.default)(registryOutput, regexp))[0];
        return match === null || match === void 0 ? void 0 : match.groups.data;
    });
}
function setEnvVarInRegistry(envVarName, envVarValue, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const regType = opts.expandableString ? 'REG_EXPAND_SZ' : 'REG_SZ';
        try {
            yield (0, safe_execa_1.default)('reg', ['add', REG_KEY, '/v', envVarName, '/t', regType, '/d', envVarValue, '/f'], EXEC_OPTS);
        }
        catch (err) { // eslint-disable-line
            throw new error_1.PnpmError('FAILED_SET_ENV', `Failed to set "${envVarName}" to "${envVarValue}": ${err.stderr}`);
        }
    });
}
// When setting environment variables through the registry, they will not be recognized immediately.
// There is a workaround though, to set at least one environment variable with `setx`.
// We have some redundancy here because we run it for each env var.
// It would be enough also to run it only for the last changed env var.
// Read more at: https://bit.ly/39OlQnF
function refreshEnvVars() {
    return __awaiter(this, void 0, void 0, function* () {
        const TEMP_ENV_VAR = 'REFRESH_ENV_VARS'; // This is just a random env var name.
        yield (0, safe_execa_1.default)('setx', [TEMP_ENV_VAR, '1'], EXEC_OPTS);
        yield (0, safe_execa_1.default)('reg', ['delete', REG_KEY, '/v', TEMP_ENV_VAR, '/f'], EXEC_OPTS);
    });
}
//# sourceMappingURL=path-extender-windows.js.map