"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchNode = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const error_1 = require("@pnpm/error");
const pick_fetcher_1 = require("@pnpm/pick-fetcher");
const create_cafs_store_1 = require("@pnpm/create-cafs-store");
const tarball_fetcher_1 = require("@pnpm/tarball-fetcher");
const adm_zip_1 = __importDefault(require("adm-zip"));
const rename_overwrite_1 = __importDefault(require("rename-overwrite"));
const tempy_1 = __importDefault(require("tempy"));
const detect_libc_1 = require("detect-libc");
const getNodeTarball_1 = require("./getNodeTarball");
async function fetchNode(fetch, version, targetDir, opts) {
    if (await (0, detect_libc_1.isNonGlibcLinux)()) {
        throw new error_1.PnpmError('MUSL', 'The current system uses the "MUSL" C standard library. Node.js currently has prebuilt artifacts only for the "glibc" libc, so we can install Node.js only for glibc');
    }
    const nodeMirrorBaseUrl = opts.nodeMirrorBaseUrl ?? 'https://nodejs.org/download/release/';
    const { tarball, pkgName } = (0, getNodeTarball_1.getNodeTarball)(version, nodeMirrorBaseUrl, process.platform, process.arch);
    if (tarball.endsWith('.zip')) {
        await downloadAndUnpackZip(fetch, tarball, targetDir, pkgName);
        return;
    }
    const getAuthHeader = () => undefined;
    const fetchers = (0, tarball_fetcher_1.createTarballFetcher)(fetch, getAuthHeader, {
        retry: opts.retry,
        timeout: opts.fetchTimeout,
        // These are not needed for fetching Node.js
        rawConfig: {},
        unsafePerm: false,
    });
    const cafs = (0, create_cafs_store_1.createCafsStore)(opts.cafsDir);
    const fetchTarball = (0, pick_fetcher_1.pickFetcher)(fetchers, { tarball });
    const { filesIndex } = await fetchTarball(cafs, { tarball }, {
        lockfileDir: process.cwd(),
    });
    await cafs.importPackage(targetDir, {
        filesResponse: {
            filesIndex: await (0, tarball_fetcher_1.waitForFilesIndex)(filesIndex),
            fromStore: false,
        },
        force: true,
    });
}
exports.fetchNode = fetchNode;
async function downloadAndUnpackZip(fetchFromRegistry, zipUrl, targetDir, pkgName) {
    const response = await fetchFromRegistry(zipUrl);
    const tmp = path_1.default.join(tempy_1.default.directory(), 'pnpm.zip');
    const dest = fs_1.default.createWriteStream(tmp);
    await new Promise((resolve, reject) => {
        response.body.pipe(dest).on('error', reject).on('close', resolve);
    });
    const zip = new adm_zip_1.default(tmp);
    const nodeDir = path_1.default.dirname(targetDir);
    zip.extractAllTo(nodeDir, true);
    await (0, rename_overwrite_1.default)(path_1.default.join(nodeDir, pkgName), targetDir);
    await fs_1.default.promises.unlink(tmp);
}
//# sourceMappingURL=index.js.map