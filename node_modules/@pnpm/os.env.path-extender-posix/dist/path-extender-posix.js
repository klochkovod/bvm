"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDirToPosixEnvPath = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const error_1 = require("@pnpm/error");
class BadShellSectionError extends error_1.PnpmError {
    constructor(opts) {
        super('BAD_SHELL_SECTION', `The config file at "${opts.configFile} already contains a ${opts.configSectionName} section but with other configuration`);
        this.current = opts.current;
        this.wanted = opts.wanted;
    }
}
function addDirToPosixEnvPath(dir, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const currentShell = detectCurrentShell();
        return yield updateShell(currentShell, dir, opts);
    });
}
exports.addDirToPosixEnvPath = addDirToPosixEnvPath;
function detectCurrentShell() {
    if (process.env.ZSH_VERSION)
        return 'zsh';
    if (process.env.BASH_VERSION)
        return 'bash';
    if (process.env.FISH_VERSION)
        return 'fish';
    return typeof process.env.SHELL === 'string' ? path_1.default.basename(process.env.SHELL) : null;
}
function updateShell(currentShell, pnpmHomeDir, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (currentShell) {
            case 'bash':
            case 'zsh':
            case 'ksh':
            case 'dash':
            case 'sh': {
                return setupShell(currentShell, pnpmHomeDir, opts);
            }
            case 'fish': {
                return setupFishShell(pnpmHomeDir, opts);
            }
        }
        const supportedShellsMsg = 'Supported shell languages are bash, zsh, fish, ksh, dash, and sh.';
        if (!currentShell)
            throw new error_1.PnpmError('UNKNOWN_SHELL', 'Could not infer shell type.', {
                hint: `Set the SHELL environment variable to your active shell.
${supportedShellsMsg}`
            });
        throw new error_1.PnpmError('UNSUPPORTED_SHELL', `Can't setup configuration for "${currentShell}" shell`, {
            hint: supportedShellsMsg,
        });
    });
}
function setupShell(shell, dir, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const configFile = getConfigFilePath(shell);
        let newSettings;
        const _createPathValue = createPathValue.bind(null, (_a = opts.position) !== null && _a !== void 0 ? _a : 'start');
        if (opts.proxyVarName) {
            newSettings = `export ${opts.proxyVarName}="${dir}"
case ":$PATH:" in
  *":$${opts.proxyVarName}:"*) ;;
  *) export PATH="${_createPathValue(`$${opts.proxyVarName}`)}" ;;
esac`;
        }
        else {
            newSettings = `case ":$PATH:" in
  *":${dir}:"*) ;;
  *) export PATH="${_createPathValue(dir)}" ;;
esac`;
        }
        const content = wrapSettings(opts.configSectionName, newSettings);
        const { changeType, oldSettings } = yield updateShellConfig(configFile, content, opts);
        return {
            configFile: {
                path: configFile,
                changeType,
            },
            oldSettings,
            newSettings,
        };
    });
}
function getConfigFilePath(shell) {
    switch (shell) {
        case 'zsh': return path_1.default.join((process.env.ZDOTDIR || os_1.default.homedir()), `.${shell}rc`);
        case 'dash':
        case 'sh': {
            if (!process.env.ENV) {
                throw new error_1.PnpmError('NO_SHELL_CONFIG', `Cannot find a config file for ${shell}. The ENV environment variable is not set.`);
            }
            return process.env.ENV;
        }
        default: return path_1.default.join(os_1.default.homedir(), `.${shell}rc`);
    }
}
function createPathValue(position, dir) {
    return position === 'start'
        ? `${dir}:$PATH`
        : `$PATH:${dir}`;
}
function setupFishShell(dir, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const configFile = path_1.default.join(os_1.default.homedir(), '.config/fish/config.fish');
        let newSettings;
        const _createPathValue = createFishPathValue.bind(null, (_a = opts.position) !== null && _a !== void 0 ? _a : 'start');
        if (opts.proxyVarName) {
            newSettings = `set -gx ${opts.proxyVarName} "${dir}"
if not string match -q -- $${opts.proxyVarName} $PATH
  set -gx PATH ${_createPathValue(`$${opts.proxyVarName}`)}
end`;
        }
        else {
            newSettings = `if not string match -q -- "${dir}" $PATH
  set -gx PATH ${_createPathValue(dir)}
end`;
        }
        const content = wrapSettings(opts.configSectionName, newSettings);
        const { changeType, oldSettings } = yield updateShellConfig(configFile, content, opts);
        return {
            configFile: {
                path: configFile,
                changeType,
            },
            oldSettings,
            newSettings,
        };
    });
}
function wrapSettings(sectionName, settings) {
    return `# ${sectionName}
${settings}
# ${sectionName} end`;
}
function createFishPathValue(position, dir) {
    return position === 'start'
        ? `"${dir}" $PATH`
        : `$PATH "${dir}"`;
}
function updateShellConfig(configFile, newContent, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fs_1.default.existsSync(configFile)) {
            yield fs_1.default.promises.mkdir(path_1.default.dirname(configFile), { recursive: true });
            yield fs_1.default.promises.writeFile(configFile, `${newContent}\n`, 'utf8');
            return {
                changeType: 'created',
                oldSettings: '',
            };
        }
        const configContent = yield fs_1.default.promises.readFile(configFile, 'utf8');
        const match = new RegExp(`# ${opts.configSectionName}\n([\\s\\S]*)\n# ${opts.configSectionName} end`, 'g').exec(configContent);
        if (!match) {
            yield fs_1.default.promises.appendFile(configFile, `\n${newContent}\n`, 'utf8');
            return {
                changeType: 'appended',
                oldSettings: '',
            };
        }
        const oldSettings = match[1];
        if (match[0] !== newContent) {
            if (!opts.overwrite) {
                throw new BadShellSectionError({
                    configSectionName: opts.configSectionName,
                    current: match[0],
                    wanted: newContent,
                    configFile,
                });
            }
            const newConfigContent = replaceSection(configContent, newContent, opts.configSectionName);
            yield fs_1.default.promises.writeFile(configFile, newConfigContent, 'utf8');
            return {
                changeType: 'modified',
                oldSettings,
            };
        }
        return {
            changeType: 'skipped',
            oldSettings,
        };
    });
}
function replaceSection(originalContent, newSection, sectionName) {
    return originalContent.replace(new RegExp(`# ${sectionName}[\\s\\S]*# ${sectionName} end`, 'g'), newSection);
}
//# sourceMappingURL=path-extender-posix.js.map