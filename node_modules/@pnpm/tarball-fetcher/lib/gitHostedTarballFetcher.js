"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForFilesIndex = exports.createGitHostedTarballFetcher = void 0;
const logger_1 = require("@pnpm/logger");
const prepare_package_1 = require("@pnpm/prepare-package");
const p_map_values_1 = __importDefault(require("p-map-values"));
const omit_1 = __importDefault(require("ramda/src/omit"));
function createGitHostedTarballFetcher(fetchRemoteTarball, fetcherOpts) {
    const fetch = async (cafs, resolution, opts) => {
        const { filesIndex } = await fetchRemoteTarball(cafs, resolution, opts);
        try {
            const prepareResult = await prepareGitHostedPkg(filesIndex, cafs, fetcherOpts);
            if (prepareResult.ignoredBuild) {
                (0, logger_1.globalWarn)(`The git-hosted package fetched from "${resolution.tarball}" has to be built but the build scripts were ignored.`);
            }
            return { filesIndex: prepareResult.filesIndex };
        }
        catch (err) { // eslint-disable-line
            err.message = `Failed to prepare git-hosted package fetched from "${resolution.tarball}": ${err.message}`; // eslint-disable-line
            throw err;
        }
    };
    return fetch;
}
exports.createGitHostedTarballFetcher = createGitHostedTarballFetcher;
async function prepareGitHostedPkg(filesIndex, cafs, opts) {
    const tempLocation = await cafs.tempDir();
    await cafs.importPackage(tempLocation, {
        filesResponse: {
            filesIndex: await waitForFilesIndex(filesIndex),
            fromStore: false,
        },
        force: true,
    });
    const shouldBeBuilt = await (0, prepare_package_1.preparePackage)(opts, tempLocation);
    const newFilesIndex = await cafs.addFilesFromDir(tempLocation);
    // Important! We cannot remove the temp location at this stage.
    // Even though we have the index of the package,
    // the linking of files to the store is in progress.
    return {
        filesIndex: newFilesIndex,
        ignoredBuild: opts.ignoreScripts && shouldBeBuilt,
    };
}
async function waitForFilesIndex(filesIndex) {
    return (0, p_map_values_1.default)(async (fileInfo) => {
        const { integrity, checkedAt } = await fileInfo.writeResult;
        return {
            ...(0, omit_1.default)(['writeResult'], fileInfo),
            checkedAt,
            integrity: integrity.toString(),
        };
    }, filesIndex);
}
exports.waitForFilesIndex = waitForFilesIndex;
//# sourceMappingURL=gitHostedTarballFetcher.js.map