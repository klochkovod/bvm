"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDownloader = exports.TarballIntegrityError = void 0;
const core_loggers_1 = require("@pnpm/core-loggers");
const error_1 = require("@pnpm/error");
const retry = __importStar(require("@zkochan/retry"));
const ssri_1 = __importDefault(require("ssri"));
const errorTypes_1 = require("./errorTypes");
const BIG_TARBALL_SIZE = 1024 * 1024 * 5; // 5 MB
class TarballIntegrityError extends error_1.PnpmError {
    constructor(opts) {
        super('TARBALL_INTEGRITY', `Got unexpected checksum for "${opts.url}". Wanted "${opts.expected}". Got "${opts.found}".`, {
            attempts: opts.attempts,
            hint: `This error may happen when a package is republished to the registry with the same version.
In this case, the metadata in the local pnpm cache will contain the old integrity checksum.

If you think that this is the case, then run "pnpm store prune" and rerun the command that failed.
"pnpm store prune" will remove your local metadata cache.`,
        });
        this.found = opts.found;
        this.expected = opts.expected;
        this.algorithm = opts.algorithm;
        this.sri = opts.sri;
        this.url = opts.url;
    }
}
exports.TarballIntegrityError = TarballIntegrityError;
function createDownloader(fetchFromRegistry, gotOpts) {
    const retryOpts = {
        factor: 10,
        maxTimeout: 6e4,
        minTimeout: 1e4,
        retries: 2,
        ...gotOpts.retry,
    };
    return async function download(url, opts) {
        const authHeaderValue = opts.getAuthHeaderByURI(url);
        const op = retry.operation(retryOpts);
        return new Promise((resolve, reject) => {
            op.attempt(async (attempt) => {
                try {
                    resolve(await fetch(attempt));
                }
                catch (error) { // eslint-disable-line
                    if (error.response?.status === 401 ||
                        error.response?.status === 403 ||
                        error.code === 'ERR_PNPM_PREPARE_PKG_FAILURE') {
                        reject(error);
                        return;
                    }
                    const timeout = op.retry(error);
                    if (timeout === false) {
                        reject(op.mainError());
                        return;
                    }
                    core_loggers_1.requestRetryLogger.debug({
                        attempt,
                        error,
                        maxRetries: retryOpts.retries,
                        method: 'GET',
                        timeout,
                        url,
                    });
                }
            });
        });
        async function fetch(currentAttempt) {
            try {
                const res = await fetchFromRegistry(url, {
                    authHeaderValue,
                    // The fetch library can retry requests on bad HTTP responses.
                    // However, it is not enough to retry on bad HTTP responses only.
                    // Requests should also be retried when the tarball's integrity check fails.
                    // Hence, we tell fetch to not retry,
                    // and we perform the retries from this function instead.
                    retry: { retries: 0 },
                    timeout: gotOpts.timeout,
                });
                if (res.status !== 200) {
                    throw new error_1.FetchError({ url, authHeaderValue }, res);
                }
                const contentLength = res.headers.has('content-length') && res.headers.get('content-length');
                const size = typeof contentLength === 'string'
                    ? parseInt(contentLength, 10)
                    : null;
                if (opts.onStart != null) {
                    opts.onStart(size, currentAttempt);
                }
                // In order to reduce the amount of logs, we only report the download progress of big tarballs
                const onProgress = size != null && size >= BIG_TARBALL_SIZE
                    ? opts.onProgress
                    : undefined;
                let downloaded = 0;
                res.body.on('data', (chunk) => {
                    downloaded += chunk.length;
                    if (onProgress != null)
                        onProgress(downloaded);
                });
                // eslint-disable-next-line no-async-promise-executor
                return await new Promise(async (resolve, reject) => {
                    const stream = res.body
                        .on('error', reject);
                    try {
                        const [integrityCheckResult, filesIndex] = await Promise.all([
                            opts.integrity ? safeCheckStream(res.body, opts.integrity, url) : true,
                            opts.cafs.addFilesFromTarball(res.body, opts.manifest),
                            waitTillClosed({ stream, size, getDownloaded: () => downloaded, url }),
                        ]);
                        if (integrityCheckResult !== true) {
                            // eslint-disable-next-line
                            throw integrityCheckResult;
                        }
                        resolve({ filesIndex });
                    }
                    catch (err) { // eslint-disable-line
                        // If the error is not an integrity check error, then it happened during extracting the tarball
                        if (err['code'] !== 'ERR_PNPM_TARBALL_INTEGRITY' &&
                            err['code'] !== 'ERR_PNPM_BAD_TARBALL_SIZE') {
                            const extractError = new error_1.PnpmError('TARBALL_EXTRACT', `Failed to unpack the tarball from "${url}": ${err.message}`);
                            reject(extractError);
                            return;
                        }
                        reject(err);
                    }
                });
            }
            catch (err) { // eslint-disable-line
                err.attempts = currentAttempt;
                err.resource = url;
                throw err;
            }
        }
    };
}
exports.createDownloader = createDownloader;
async function safeCheckStream(stream, integrity, url) {
    try {
        await ssri_1.default.checkStream(stream, integrity);
        return true;
    }
    catch (err) { // eslint-disable-line
        return new TarballIntegrityError({
            algorithm: err['algorithm'],
            expected: err['expected'],
            found: err['found'],
            sri: err['sri'],
            url,
        });
    }
}
async function waitTillClosed(opts) {
    return new Promise((resolve, reject) => {
        opts.stream.on('end', () => {
            const downloaded = opts.getDownloaded();
            if (opts.size !== null && opts.size !== downloaded) {
                const err = new errorTypes_1.BadTarballError({
                    expectedSize: opts.size,
                    receivedSize: downloaded,
                    tarballUrl: opts.url,
                });
                reject(err);
                return;
            }
            resolve();
        });
    });
}
//# sourceMappingURL=remoteTarballFetcher.js.map