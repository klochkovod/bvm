"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchFromDir = exports.createDirectoryFetcher = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const logger_1 = require("@pnpm/logger");
const read_project_manifest_1 = require("@pnpm/read-project-manifest");
const npm_packlist_1 = __importDefault(require("npm-packlist"));
const directoryFetcherLogger = (0, logger_1.logger)('directory-fetcher');
function createDirectoryFetcher(opts) {
    const readFileStat = opts?.resolveSymlinks === true ? realFileStat : fileStat;
    const fetchFromDir = opts?.includeOnlyPackageFiles ? fetchPackageFilesFromDir : fetchAllFilesFromDir.bind(null, readFileStat);
    const directoryFetcher = (cafs, resolution, opts) => {
        const dir = path_1.default.join(opts.lockfileDir, resolution.directory);
        return fetchFromDir(dir, opts);
    };
    return {
        directory: directoryFetcher,
    };
}
exports.createDirectoryFetcher = createDirectoryFetcher;
async function fetchFromDir(dir, opts) {
    if (opts.includeOnlyPackageFiles) {
        return fetchPackageFilesFromDir(dir, opts);
    }
    const readFileStat = opts?.resolveSymlinks === true ? realFileStat : fileStat;
    return fetchAllFilesFromDir(readFileStat, dir, opts);
}
exports.fetchFromDir = fetchFromDir;
async function fetchAllFilesFromDir(readFileStat, dir, opts) {
    const filesIndex = await _fetchAllFilesFromDir(readFileStat, dir);
    if (opts.manifest) {
        // In a regular pnpm workspace it will probably never happen that a dependency has no package.json file.
        // Safe read was added to support the Bit workspace in which the components have no package.json files.
        // Related PR in Bit: https://github.com/teambit/bit/pull/5251
        const manifest = await (0, read_project_manifest_1.safeReadProjectManifestOnly)(dir) ?? {};
        opts.manifest.resolve(manifest); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    return {
        local: true,
        filesIndex,
        packageImportMethod: 'hardlink',
    };
}
async function _fetchAllFilesFromDir(readFileStat, dir, relativeDir = '') {
    const filesIndex = {};
    const files = await fs_1.promises.readdir(dir);
    await Promise.all(files
        .filter((file) => file !== 'node_modules')
        .map(async (file) => {
        const { filePath, stat } = await readFileStat(path_1.default.join(dir, file));
        if (!filePath)
            return;
        const relativeSubdir = `${relativeDir}${relativeDir ? '/' : ''}${file}`;
        if (stat.isDirectory()) {
            const subFilesIndex = await _fetchAllFilesFromDir(readFileStat, filePath, relativeSubdir);
            Object.assign(filesIndex, subFilesIndex);
        }
        else {
            filesIndex[relativeSubdir] = filePath;
        }
    }));
    return filesIndex;
}
async function realFileStat(filePath) {
    let stat = await fs_1.promises.lstat(filePath);
    if (!stat.isSymbolicLink()) {
        return { filePath, stat };
    }
    try {
        filePath = await fs_1.promises.realpath(filePath);
        stat = await fs_1.promises.stat(filePath);
        return { filePath, stat };
    }
    catch (err) { // eslint-disable-line @typescript-eslint/no-explicit-any
        // Broken symlinks are skipped
        if (err.code === 'ENOENT') {
            directoryFetcherLogger.debug({ brokenSymlink: filePath });
            return { filePath: null, stat: null };
        }
        throw err;
    }
}
async function fileStat(filePath) {
    try {
        return {
            filePath,
            stat: await fs_1.promises.stat(filePath),
        };
    }
    catch (err) { // eslint-disable-line @typescript-eslint/no-explicit-any
        // Broken symlinks are skipped
        if (err.code === 'ENOENT') {
            directoryFetcherLogger.debug({ brokenSymlink: filePath });
            return { filePath: null, stat: null };
        }
        throw err;
    }
}
async function fetchPackageFilesFromDir(dir, opts) {
    const files = await (0, npm_packlist_1.default)({ path: dir });
    const filesIndex = Object.fromEntries(files.map((file) => [file, path_1.default.join(dir, file)]));
    if (opts.manifest) {
        // In a regular pnpm workspace it will probably never happen that a dependency has no package.json file.
        // Safe read was added to support the Bit workspace in which the components have no package.json files.
        // Related PR in Bit: https://github.com/teambit/bit/pull/5251
        const manifest = await (0, read_project_manifest_1.safeReadProjectManifestOnly)(dir) ?? {};
        opts.manifest.resolve(manifest); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    return {
        local: true,
        filesIndex,
        packageImportMethod: 'hardlink',
    };
}
//# sourceMappingURL=index.js.map