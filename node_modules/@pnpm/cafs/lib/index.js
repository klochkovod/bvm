"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCafs = exports.getFilePathInCafs = exports.getFilePathByModeInCafs = exports.readManifestFromStore = exports.checkPkgFilesIntegrity = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const get_stream_1 = __importDefault(require("get-stream"));
const path_temp_1 = __importDefault(require("path-temp"));
const rename_overwrite_1 = __importDefault(require("rename-overwrite"));
const ssri_1 = __importDefault(require("ssri"));
const addFilesFromDir_1 = require("./addFilesFromDir");
const addFilesFromTarball_1 = require("./addFilesFromTarball");
const checkPkgFilesIntegrity_1 = require("./checkPkgFilesIntegrity");
Object.defineProperty(exports, "checkPkgFilesIntegrity", { enumerable: true, get: function () { return checkPkgFilesIntegrity_1.checkPkgFilesIntegrity; } });
const readManifestFromStore_1 = require("./readManifestFromStore");
Object.defineProperty(exports, "readManifestFromStore", { enumerable: true, get: function () { return readManifestFromStore_1.readManifestFromStore; } });
const getFilePathInCafs_1 = require("./getFilePathInCafs");
Object.defineProperty(exports, "getFilePathInCafs", { enumerable: true, get: function () { return getFilePathInCafs_1.getFilePathInCafs; } });
Object.defineProperty(exports, "getFilePathByModeInCafs", { enumerable: true, get: function () { return getFilePathInCafs_1.getFilePathByModeInCafs; } });
const writeFile_1 = require("./writeFile");
function createCafs(cafsDir, ignore) {
    const locker = new Map();
    const _writeBufferToCafs = writeBufferToCafs.bind(null, locker, cafsDir);
    const addStream = addStreamToCafs.bind(null, _writeBufferToCafs);
    const addBuffer = addBufferToCafs.bind(null, _writeBufferToCafs);
    return {
        addFilesFromDir: addFilesFromDir_1.addFilesFromDir.bind(null, { addBuffer, addStream }),
        addFilesFromTarball: addFilesFromTarball_1.addFilesFromTarball.bind(null, addStream, ignore ?? null),
        getFilePathInCafs: getFilePathInCafs_1.getFilePathInCafs.bind(null, cafsDir),
        getFilePathByModeInCafs: getFilePathInCafs_1.getFilePathByModeInCafs.bind(null, cafsDir),
    };
}
exports.createCafs = createCafs;
async function addStreamToCafs(writeBufferToCafs, fileStream, mode) {
    const buffer = await get_stream_1.default.buffer(fileStream);
    return addBufferToCafs(writeBufferToCafs, buffer, mode);
}
async function addBufferToCafs(writeBufferToCafs, buffer, mode) {
    // Calculating the integrity of the file is surprisingly fast.
    // 30K files are calculated in 1 second.
    // Hence, from a performance perspective, there is no win in fetching the package index file from the registry.
    const integrity = ssri_1.default.fromData(buffer);
    const isExecutable = (0, getFilePathInCafs_1.modeIsExecutable)(mode);
    const fileDest = (0, getFilePathInCafs_1.contentPathFromHex)(isExecutable ? 'exec' : 'nonexec', integrity.hexDigest());
    const checkedAt = await writeBufferToCafs(buffer, fileDest, isExecutable ? 0o755 : undefined, integrity);
    return { checkedAt, integrity };
}
async function writeBufferToCafs(locker, cafsDir, buffer, fileDest, mode, integrity) {
    fileDest = path_1.default.join(cafsDir, fileDest);
    if (locker.has(fileDest)) {
        return locker.get(fileDest);
    }
    const p = (async () => {
        // This part is a bit redundant.
        // When a file is already used by another package,
        // we probably have validated its content already.
        // However, there is no way to find which package index file references
        // the given file. So we should revalidate the content of the file again.
        if (await existsSame(fileDest, integrity)) {
            return Date.now();
        }
        // This might be too cautious.
        // The write is atomic, so in case pnpm crashes, no broken file
        // will be added to the store.
        // It might be a redundant step though, as we verify the contents of the
        // files before linking
        //
        // If we don't allow --no-verify-store-integrity then we probably can write
        // to the final file directly.
        const temp = (0, path_temp_1.default)(path_1.default.dirname(fileDest));
        await (0, writeFile_1.writeFile)(temp, buffer, mode);
        // Unfortunately, "birth time" (time of file creation) is available not on all filesystems.
        // We log the creation time ourselves and save it in the package index file.
        // Having this information allows us to skip content checks for files that were not modified since "birth time".
        const birthtimeMs = Date.now();
        await (0, rename_overwrite_1.default)(temp, fileDest);
        return birthtimeMs;
    })();
    locker.set(fileDest, p);
    return p;
}
async function existsSame(filename, integrity) {
    let existingFile;
    try {
        existingFile = await fs_1.promises.stat(filename);
    }
    catch (err) {
        return false;
    }
    return (0, checkPkgFilesIntegrity_1.verifyFileIntegrity)(filename, {
        size: existingFile.size,
        integrity,
    });
}
//# sourceMappingURL=index.js.map