"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyFileIntegrity = exports.checkPkgFilesIntegrity = void 0;
const fs_1 = require("fs");
const graceful_fs_1 = __importDefault(require("@pnpm/graceful-fs"));
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const p_limit_1 = __importDefault(require("p-limit"));
const ssri_1 = __importDefault(require("ssri"));
const getFilePathInCafs_1 = require("./getFilePathInCafs");
const parseJson_1 = require("./parseJson");
const limit = (0, p_limit_1.default)(20);
const MAX_BULK_SIZE = 1 * 1024 * 1024; // 1MB
// We track how many files were checked during installation.
// It should be rare that a files content should be checked.
// If it happens too frequently, something is wrong.
// Checking a file's integrity is an expensive operation!
// @ts-expect-error
global['verifiedFileIntegrity'] = 0;
async function checkPkgFilesIntegrity(cafsDir, pkgIndex, manifest) {
    // It might make sense to use this cache for all files in the store
    // but there's a smaller chance that the same file will be checked twice
    // so it's probably not worth the memory (this assumption should be verified)
    const verifiedFilesCache = new Set();
    const _checkFilesIntegrity = checkFilesIntegrity.bind(null, verifiedFilesCache, cafsDir);
    const verified = await _checkFilesIntegrity(pkgIndex.files, manifest);
    if (!verified)
        return false;
    if (pkgIndex.sideEffects) {
        // We verify all side effects cache. We could optimize it to verify only the side effects cache
        // that satisfies the current os/arch/platform.
        // However, it likely won't make a big difference.
        await Promise.all(Object.entries(pkgIndex.sideEffects).map(async ([sideEffectName, files]) => {
            if (!await _checkFilesIntegrity(files)) {
                delete pkgIndex.sideEffects[sideEffectName];
            }
        }));
    }
    return true;
}
exports.checkPkgFilesIntegrity = checkPkgFilesIntegrity;
async function checkFilesIntegrity(verifiedFilesCache, cafsDir, files, manifest) {
    let allVerified = true;
    await Promise.all(Object.entries(files)
        .map(async ([f, fstat]) => limit(async () => {
        if (!fstat.integrity) {
            throw new Error(`Integrity checksum is missing for ${f}`);
        }
        const filename = (0, getFilePathInCafs_1.getFilePathByModeInCafs)(cafsDir, fstat.integrity, fstat.mode);
        const deferredManifest = manifest && f === 'package.json' ? manifest : undefined;
        if (!deferredManifest && verifiedFilesCache.has(filename))
            return;
        if (await verifyFile(filename, fstat, deferredManifest)) {
            verifiedFilesCache.add(filename);
        }
        else {
            allVerified = false;
        }
    })));
    return allVerified;
}
async function verifyFile(filename, fstat, deferredManifest) {
    const currentFile = await checkFile(filename, fstat.checkedAt);
    if (currentFile == null)
        return false;
    if (currentFile.isModified) {
        if (currentFile.size !== fstat.size) {
            await (0, rimraf_1.default)(filename);
            return false;
        }
        return verifyFileIntegrity(filename, fstat, deferredManifest);
    }
    if (deferredManifest != null) {
        (0, parseJson_1.parseJsonBuffer)(await graceful_fs_1.default.readFile(filename), deferredManifest);
    }
    // If a file was not edited, we are skipping integrity check.
    // We assume that nobody will manually remove a file in the store and create a new one.
    return true;
}
async function verifyFileIntegrity(filename, expectedFile, deferredManifest) {
    // @ts-expect-error
    global['verifiedFileIntegrity']++;
    try {
        if (expectedFile.size > MAX_BULK_SIZE && (deferredManifest == null)) {
            const ok = Boolean(await ssri_1.default.checkStream(graceful_fs_1.default.createReadStream(filename), expectedFile.integrity));
            if (!ok) {
                await (0, rimraf_1.default)(filename);
            }
            return ok;
        }
        const data = await graceful_fs_1.default.readFile(filename);
        const ok = Boolean(ssri_1.default.checkData(data, expectedFile.integrity));
        if (!ok) {
            await (0, rimraf_1.default)(filename);
        }
        else if (deferredManifest != null) {
            (0, parseJson_1.parseJsonBuffer)(data, deferredManifest);
        }
        return ok;
    }
    catch (err) { // eslint-disable-line
        switch (err.code) {
            case 'ENOENT': return false;
            case 'EINTEGRITY': {
                // Broken files are removed from the store
                await (0, rimraf_1.default)(filename);
                return false;
            }
        }
        throw err;
    }
}
exports.verifyFileIntegrity = verifyFileIntegrity;
async function checkFile(filename, checkedAt) {
    try {
        const { mtimeMs, size } = await fs_1.promises.stat(filename);
        return {
            isModified: (mtimeMs - (checkedAt ?? 0)) > 100,
            size,
        };
    }
    catch (err) { // eslint-disable-line
        if (err.code === 'ENOENT')
            return null;
        throw err;
    }
}
//# sourceMappingURL=checkPkgFilesIntegrity.js.map