"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFilesFromTarball = void 0;
const gunzip_maybe_1 = __importDefault(require("gunzip-maybe"));
const tar_stream_1 = __importDefault(require("tar-stream"));
const parseJson_1 = require("./parseJson");
async function addFilesFromTarball(addStreamToCafs, _ignore, stream, manifest) {
    const ignore = _ignore ?? (() => false);
    const extract = tar_stream_1.default.extract();
    const filesIndex = {};
    await new Promise((resolve, reject) => {
        extract.on('entry', (header, fileStream, next) => {
            // There are some edge cases, where the same files are extracted multiple times.
            // So there will be an entry for "lib/index.js" and another one for "lib//index.js",
            // which are the same file.
            // Hence, we are normalizing the file name, replacing // with / and checking for duplicates.
            // Example of such package: @pnpm/colorize-semver-diff@1.0.1
            const filename = header.name.slice(header.name.indexOf('/') + 1).replace(/\/\//g, '/');
            if (header.type !== 'file' || ignore(filename) || filesIndex[filename]) {
                fileStream.resume();
                next();
                return;
            }
            if (filename === 'package.json' && (manifest != null)) {
                (0, parseJson_1.parseJsonStream)(fileStream, manifest);
            }
            const writeResult = addStreamToCafs(fileStream, header.mode);
            filesIndex[filename] = {
                mode: header.mode,
                size: header.size,
                writeResult,
            };
            next();
        });
        // listener
        extract.on('finish', () => {
            resolve();
        });
        extract.on('error', reject);
        // pipe through extractor
        stream
            .on('error', reject)
            .pipe((0, gunzip_maybe_1.default)())
            .on('error', reject).pipe(extract);
    });
    if (!filesIndex['package.json'] && manifest != null) {
        manifest.resolve(undefined);
    }
    return filesIndex;
}
exports.addFilesFromTarball = addFilesFromTarball;
//# sourceMappingURL=addFilesFromTarball.js.map