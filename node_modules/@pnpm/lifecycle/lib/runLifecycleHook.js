"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runLifecycleHook = void 0;
const core_loggers_1 = require("@pnpm/core-loggers");
const logger_1 = require("@pnpm/logger");
const npm_lifecycle_1 = __importDefault(require("@pnpm/npm-lifecycle"));
const error_1 = require("@pnpm/error");
const fs_1 = require("fs");
function noop() { } // eslint-disable-line:no-empty
async function runLifecycleHook(stage, manifest, opts) {
    const optional = opts.optional === true;
    const m = { _id: getId(manifest), ...manifest };
    m.scripts = { ...m.scripts };
    if (stage === 'start' && !m.scripts.start) {
        if (!(0, fs_1.existsSync)('server.js')) {
            throw new error_1.PnpmError('NO_SCRIPT_OR_SERVER', 'Missing script start or file server.js');
        }
        m.scripts.start = 'node server.js';
    }
    if (opts.args?.length && m.scripts?.[stage]) {
        const escapedArgs = opts.args.map((arg) => JSON.stringify(arg));
        m.scripts[stage] = `${m.scripts[stage]} ${escapedArgs.join(' ')}`;
    }
    // This script is used to prevent the usage of npm or Yarn.
    // It does nothing, when pnpm is used, so we may skip its execution.
    if (m.scripts[stage] === 'npx only-allow pnpm')
        return;
    if (opts.stdio !== 'inherit') {
        core_loggers_1.lifecycleLogger.debug({
            depPath: opts.depPath,
            optional,
            script: m.scripts[stage],
            stage,
            wd: opts.pkgRoot,
        });
    }
    const logLevel = (opts.stdio !== 'inherit' || opts.silent)
        ? 'silent'
        : undefined;
    await (0, npm_lifecycle_1.default)(m, stage, opts.pkgRoot, {
        config: opts.rawConfig,
        dir: opts.rootModulesDir,
        extraBinPaths: opts.extraBinPaths ?? [],
        extraEnv: {
            ...opts.extraEnv,
            INIT_CWD: opts.initCwd ?? process.cwd(),
            PNPM_SCRIPT_SRC_DIR: opts.pkgRoot,
        },
        log: {
            clearProgress: noop,
            info: noop,
            level: logLevel,
            pause: noop,
            resume: noop,
            showProgress: noop,
            silly: npmLog,
            verbose: npmLog,
            warn: (...msg) => {
                (0, logger_1.globalWarn)(msg.join(' '));
            },
        },
        runConcurrently: true,
        scriptsPrependNodePath: opts.scriptsPrependNodePath,
        scriptShell: opts.scriptShell,
        shellEmulator: opts.shellEmulator,
        stdio: opts.stdio ?? 'pipe',
        unsafePerm: opts.unsafePerm,
    });
    function npmLog(prefix, logid, stdtype, line) {
        switch (stdtype) {
            case 'stdout':
            case 'stderr':
                core_loggers_1.lifecycleLogger.debug({
                    depPath: opts.depPath,
                    line: line.toString(),
                    stage,
                    stdio: stdtype,
                    wd: opts.pkgRoot,
                });
                return;
            case 'Returned: code:': {
                if (opts.stdio === 'inherit') {
                    // Preventing the pnpm reporter from overriding the project's script output
                    return;
                }
                const code = arguments[3] ?? 1;
                core_loggers_1.lifecycleLogger.debug({
                    depPath: opts.depPath,
                    exitCode: code,
                    optional,
                    stage,
                    wd: opts.pkgRoot,
                });
            }
        }
    }
}
exports.runLifecycleHook = runLifecycleHook;
function getId(manifest) {
    return `${manifest.name ?? ''}@${manifest.version ?? ''}`;
}
//# sourceMappingURL=runLifecycleHook.js.map