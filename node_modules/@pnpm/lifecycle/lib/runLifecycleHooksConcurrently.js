"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runLifecycleHooksConcurrently = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const directory_fetcher_1 = require("@pnpm/directory-fetcher");
const run_groups_1 = __importDefault(require("run-groups"));
const runLifecycleHook_1 = require("./runLifecycleHook");
async function runLifecycleHooksConcurrently(stages, importers, childConcurrency, opts) {
    const importersByBuildIndex = new Map();
    for (const importer of importers) {
        if (!importersByBuildIndex.has(importer.buildIndex)) {
            importersByBuildIndex.set(importer.buildIndex, [importer]);
        }
        else {
            importersByBuildIndex.get(importer.buildIndex).push(importer);
        }
    }
    const sortedBuildIndexes = Array.from(importersByBuildIndex.keys()).sort((a, b) => a - b);
    const groups = sortedBuildIndexes.map((buildIndex) => {
        const importers = importersByBuildIndex.get(buildIndex);
        return importers.map(({ manifest, modulesDir, rootDir, stages: importerStages, targetDirs }) => async () => {
            const runLifecycleHookOpts = {
                ...opts,
                depPath: rootDir,
                pkgRoot: rootDir,
                rootModulesDir: modulesDir,
            };
            let isBuilt = false;
            for (const stage of (importerStages ?? stages)) {
                if ((manifest.scripts == null) || !manifest.scripts[stage])
                    continue;
                await (0, runLifecycleHook_1.runLifecycleHook)(stage, manifest, runLifecycleHookOpts);
                isBuilt = true;
            }
            if (targetDirs == null || targetDirs.length === 0 || !isBuilt)
                return;
            const filesResponse = await (0, directory_fetcher_1.fetchFromDir)(rootDir, { resolveSymlinks: opts.resolveSymlinksInInjectedDirs });
            await Promise.all(targetDirs.map(async (targetDir) => {
                const targetModulesDir = path_1.default.join(targetDir, 'node_modules');
                const nodeModulesIndex = {};
                if (fs_1.default.existsSync(targetModulesDir)) {
                    // If the target directory contains a node_modules directory
                    // (it may happen when the hoisted node linker is used)
                    // then we need to preserve this node_modules.
                    // So we scan this node_modules directory and  pass it as part of the new package.
                    await scanDir('node_modules', targetModulesDir, targetModulesDir, nodeModulesIndex);
                }
                return opts.storeController.importPackage(targetDir, {
                    filesResponse: {
                        fromStore: false,
                        ...filesResponse,
                        filesIndex: {
                            ...filesResponse.filesIndex,
                            ...nodeModulesIndex,
                        },
                    },
                    force: false,
                });
            }));
        });
    });
    await (0, run_groups_1.default)(childConcurrency, groups);
}
exports.runLifecycleHooksConcurrently = runLifecycleHooksConcurrently;
async function scanDir(prefix, rootDir, currentDir, index) {
    const files = await fs_1.default.promises.readdir(currentDir);
    await Promise.all(files.map(async (file) => {
        const fullPath = path_1.default.join(currentDir, file);
        const stat = await fs_1.default.promises.stat(fullPath);
        if (stat.isDirectory()) {
            return scanDir(prefix, rootDir, fullPath, index);
        }
        if (stat.isFile()) {
            const relativePath = path_1.default.relative(rootDir, fullPath);
            index[path_1.default.join(prefix, relativePath)] = fullPath;
        }
    }));
}
//# sourceMappingURL=runLifecycleHooksConcurrently.js.map