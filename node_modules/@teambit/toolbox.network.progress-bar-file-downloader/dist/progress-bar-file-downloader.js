"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.download = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const node_fetch_progress_1 = __importDefault(require("node-fetch-progress"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const util_1 = __importDefault(require("util"));
const stream_1 = require("stream");
const toolbox_network_agent_1 = require("@teambit/toolbox.network.agent");
const streamPipeline = util_1.default.promisify(stream_1.pipeline);
const defaults = {
    ensureDir: true,
    overrideExisting: false,
};
const defaultProgressBarOpts = {
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true,
    stopOnComplete: true,
    clearOnComplete: true,
    format: '[{bar}] {percentage}% | ETA: {etah} | Speed: {speed}',
};
function download(url, destination, opts = defaults, progressBarOpts = defaultProgressBarOpts, proxyConfig = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const concreteProgressBarOpts = Object.assign({}, defaultProgressBarOpts, progressBarOpts);
        const bar = new cli_progress_1.default.SingleBar(concreteProgressBarOpts);
        const finalOpts = Object.assign({}, defaults, opts);
        const exists = yield fs_extra_1.default.pathExists(destination);
        if (exists && !finalOpts.overrideExisting) {
            throw new Error(`path ${destination} already exists`);
        }
        const dirname = path_1.default.dirname(destination);
        if (finalOpts.ensureDir) {
            yield fs_extra_1.default.ensureDir(dirname);
        }
        const response = yield (0, node_fetch_1.default)(url, { agent: (0, toolbox_network_agent_1.getAgent)(url, proxyConfig) });
        const progress = new node_fetch_progress_1.default(response, { throttle: 100 });
        bar.start(1, 0, { speed: 'N/A' });
        progress.on('progress', (p) => bar.update(p.progress, { speed: p.rateh, etah: p.etah }));
        if (!response.ok)
            throw new Error(`unexpected response ${response.statusText}`);
        yield streamPipeline(response.body, fs_extra_1.default.createWriteStream(destination));
        return;
    });
}
exports.download = download;
//# sourceMappingURL=progress-bar-file-downloader.js.map