"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.command = exports.UpgradeCmd = void 0;
const bvm_install_1 = require("@teambit/bvm.install");
const chalk_1 = __importDefault(require("chalk"));
const bvm_version_1 = require("@teambit/bvm.version");
class UpgradeCmd {
    constructor() {
        this.aliases = ["u", "upgrade"];
        this.describe = "install latest bit version from the server, update the current version, and delete the previous installed version";
        this.command = ["upgrade"];
    }
    builder(yargs) {
        yargs
            .option({
            "skip-update-path": {
                describe: "don't add the bvm directory to the system PATH",
                default: false,
                type: "boolean",
            },
        })
            .option({
            "use-system-node": {
                describe: "use the Node.js installed on the system to run Bit CLI",
                default: false,
                type: "boolean",
            },
        })
            .option({
            "skip-update-check": {
                describe: "skip checking for a newer version of BVM",
                default: false,
                type: "boolean",
            },
        })
            .option({
            'extract-method': {
                describe: 'EXPERIMENTAL. change the extraction method',
                type: 'string',
                choices: ['default', 'child-process'],
            }
        })
            .option({
            os: {
                describe: "override the os type",
                type: "string",
                choices: ["linux", "darwin", "win"],
            },
            arch: {
                describe: "override the arch type",
                type: "string",
                choices: ["x64", "arm64"],
            },
        })
            .example("$0 upgrade", "install latest bit version from the server, update the current version, and delete the previous installed version");
        return yargs;
    }
    handler(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args.skipUpdateCheck) {
                const currentBvmVersion = yield (0, bvm_version_1.getBvmLocalVersion)();
                const latestBvmRemoteVersion = yield (0, bvm_version_1.getBvmRemoteVersion)();
                const upgradeBvmMsg = (0, bvm_version_1.getNewerBvmAvailableOutput)(currentBvmVersion, latestBvmRemoteVersion);
                if (upgradeBvmMsg) {
                    console.log(chalk_1.default.yellow(upgradeBvmMsg));
                }
            }
            const upgradeResults = yield (0, bvm_install_1.installVersion)("latest", {
                override: false,
                replace: true,
                useSystemNode: args.useSystemNode,
                extractMethod: args.extractMethod,
                addToPathIfMissing: !args.skipUpdatePath,
                os: args.os,
                arch: args.arch,
            });
            return printOutput(upgradeResults);
        });
    }
}
exports.UpgradeCmd = UpgradeCmd;
exports.command = new UpgradeCmd();
function formatOutput(upgradeResults) {
    const replacedText = upgradeResults.previousCurrentVersion
        ? `upgraded from version ${chalk_1.default.green(upgradeResults.previousCurrentVersion)}`
        : undefined;
    const currentText = `current is now linked to version ${chalk_1.default.green(upgradeResults.installedVersion)} in path ${chalk_1.default.green(upgradeResults.versionPath)}`;
    return [replacedText, currentText].filter((msg) => msg).join("\n");
}
function printOutput(upgradeResults) {
    const output = formatOutput(upgradeResults);
    console.log(output);
    return output;
}
//# sourceMappingURL=upgrade.js.map