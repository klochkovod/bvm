"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetch = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const bvm_list_1 = require("@teambit/bvm.list");
const bvm_config_1 = require("@teambit/bvm.config");
const toolbox_network_progress_bar_file_downloader_1 = require("@teambit/toolbox.network.progress-bar-file-downloader");
const ora_1 = __importDefault(require("ora"));
const toolbox_time_time_format_1 = require("@teambit/toolbox.time.time-format");
const bvm_error_1 = require("@teambit/bvm.error");
const bvm_fs_tar_version_1 = require("@teambit/bvm.fs-tar-version");
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const config = bvm_config_1.Config.load();
const defaultOpts = {
    override: false,
    overrideDir: false,
};
const loader = (0, ora_1.default)();
function fetch(version, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const concreteOpts = Object.assign({}, defaultOpts, opts);
        const listOpts = (0, lodash_pick_1.default)(concreteOpts, ['os', 'arch', 'releaseType']);
        const remoteVersionList = yield (0, bvm_list_1.listRemote)(listOpts);
        let resolvedVersion;
        if (!version || version === 'latest') {
            resolvedVersion = remoteVersionList.latest();
        }
        else {
            resolvedVersion = remoteVersionList.find(version);
            if (!resolvedVersion) {
                // If the given version is not found, try to fetch it from the old location
                const oldVersions = yield (0, bvm_list_1.listRemote)(Object.assign(Object.assign({}, listOpts), { releaseType: bvm_list_1.ReleaseTypeFilter.NIGHTLY_FROM_OLD_LOCATION }));
                resolvedVersion = oldVersions.find(version);
            }
        }
        if (!resolvedVersion) {
            throw new bvm_error_1.BvmError(`version ${version} not found on remote, use bvm list --remote to see available versions`);
        }
        const url = resolvedVersion.url;
        // const { versionDir, exists } = config.getSpecificVersionDir(resolvedVersion.version);
        const fileName = url.split('/').pop();
        const destinationDir = opts.destinationDir;
        const destination = path_1.default.join(destinationDir, fileName);
        const destinationDirExists = yield fs_extra_1.default.pathExists(destinationDir);
        if (destinationDirExists) {
            if (concreteOpts.overrideDir) {
                yield fs_extra_1.default.remove(destinationDir);
            }
        }
        const destinationExists = yield fs_extra_1.default.pathExists(destination);
        if (destinationExists) {
            if (!concreteOpts.override) {
                throw new bvm_error_1.BvmError(`the destination location at ${destination} already exist`);
            }
            yield fs_extra_1.default.remove(destination);
        }
        const downloadLoaderText = `downloading version ${resolvedVersion.version}`;
        const downloadStartTime = Date.now();
        const progressBarOpts = {
            format: `downloading version ${resolvedVersion.version} [{bar}] {percentage}% | ETA: {etah} | Speed: {speed}`,
        };
        yield (0, toolbox_network_progress_bar_file_downloader_1.download)(url, destination, {}, progressBarOpts, Object.assign(Object.assign({}, config.networkConfig()), config.proxyConfig()));
        const downloadEndTime = Date.now();
        const downloadTimeDiff = (0, toolbox_time_time_format_1.timeFormat)(downloadEndTime - downloadStartTime);
        loader.succeed(`${downloadLoaderText} in ${downloadTimeDiff}`);
        // return { downloadedFile: destination, resolvedVersion: resolvedVersion.version };
        return new bvm_fs_tar_version_1.FsTarVersion(destination);
    });
}
exports.fetch = fetch;
//# sourceMappingURL=fetch.js.map