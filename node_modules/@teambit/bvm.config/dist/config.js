"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = exports.KNOWN_KEYS = exports.CFG_PROXY_KEY = exports.CFG_PROXY_CERT = exports.CFG_PROXY_STRICT_SSL = exports.CFG_GCP_SECRET_KEY = exports.CFG_GCP_ACCESS_KEY = exports.CFG_NETWORK_KEY = exports.CFG_NETWORK_CERT = exports.CFG_NETWORK_STRICT_SSL = exports.CFG_NETWORK_CA_FILE = exports.CFG_NETWORK_CA = exports.CFG_NETWORK_MAX_SOCKETS = exports.CFG_NETWORK_LOCAL_ADDRESS = exports.CFG_PROXY_NO_PROXY = exports.CFG_PROXY_CA_FILE = exports.CFG_PROXY_CA = exports.CFG_HTTPS_PROXY = exports.CFG_PROXY = exports.CFG_SKIP_TEMP_DIR = exports.CFG_EXTRACT_METHOD = exports.CFG_RELEASE_TYPE = exports.CFG_BVM_DIR = exports.NODE_VERSIONS_FOLDER_NAME = exports.BIT_VERSIONS_FOLDER_NAME = exports.LINKS_KEY = exports.ALIASES_KEY = exports.CONFIG_FILENAME = exports.CONFIG_DIR = exports.IS_WINDOWS = exports.BVM_GLOBALS_DIR_ENV_VARIABLE = exports.BVM_ENV_VARS_PREFIX = void 0;
const nconf_1 = require("nconf");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const user_home_1 = __importDefault(require("user-home"));
const lodash_pickby_1 = __importDefault(require("lodash.pickby"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const child_process_1 = require("child_process");
const semver_1 = __importDefault(require("semver"));
const chalk_1 = __importDefault(require("chalk"));
exports.BVM_ENV_VARS_PREFIX = "BVM_";
exports.BVM_GLOBALS_DIR_ENV_VARIABLE = "BVM_GLOBALS_DIR";
exports.IS_WINDOWS = os_1.default.platform() === "win32";
exports.CONFIG_DIR = "config";
exports.CONFIG_FILENAME = "config.json";
exports.ALIASES_KEY = "aliases";
exports.LINKS_KEY = "links";
exports.BIT_VERSIONS_FOLDER_NAME = "versions";
exports.NODE_VERSIONS_FOLDER_NAME = "nodejs";
const CONFIG_KEY_NAME = "global";
exports.CFG_BVM_DIR = "BVM_DIR";
exports.CFG_RELEASE_TYPE = "RELEASE_TYPE";
exports.CFG_EXTRACT_METHOD = "EXTRACT_METHOD";
exports.CFG_SKIP_TEMP_DIR = "SKIP_TEMP_DIR";
exports.CFG_PROXY = "proxy";
exports.CFG_HTTPS_PROXY = "https_proxy";
exports.CFG_PROXY_CA = "proxy.ca";
exports.CFG_PROXY_CA_FILE = "proxy.cafile";
exports.CFG_PROXY_NO_PROXY = "proxy.no_proxy";
exports.CFG_NETWORK_LOCAL_ADDRESS = "network.local_address";
exports.CFG_NETWORK_MAX_SOCKETS = "network.max_sockets";
exports.CFG_NETWORK_CA = "network.ca";
exports.CFG_NETWORK_CA_FILE = "network.cafile";
exports.CFG_NETWORK_STRICT_SSL = "network.strict-ssl";
exports.CFG_NETWORK_CERT = "network.cert";
exports.CFG_NETWORK_KEY = "network.key";
// GCP config for set releases metadata
exports.CFG_GCP_ACCESS_KEY = "gcp_access_key";
exports.CFG_GCP_SECRET_KEY = "gcp_secret_key";
// For backward compatibility
exports.CFG_PROXY_STRICT_SSL = "proxy.strict_ssl";
exports.CFG_PROXY_CERT = "proxy.cert";
exports.CFG_PROXY_KEY = "proxy.key";
exports.KNOWN_KEYS = [
    exports.CFG_BVM_DIR,
    "DEFAULT_LINK",
    exports.CFG_RELEASE_TYPE,
    exports.CFG_EXTRACT_METHOD,
    exports.CFG_SKIP_TEMP_DIR,
    exports.CFG_GCP_ACCESS_KEY,
    exports.CFG_GCP_SECRET_KEY,
    exports.CFG_PROXY,
    exports.CFG_HTTPS_PROXY,
    exports.CFG_PROXY_CA,
    exports.CFG_PROXY_CA_FILE,
    exports.CFG_PROXY_STRICT_SSL,
    exports.CFG_PROXY_CERT,
    exports.CFG_PROXY_KEY,
    exports.CFG_PROXY_NO_PROXY,
    exports.CFG_NETWORK_LOCAL_ADDRESS,
    exports.CFG_NETWORK_MAX_SOCKETS,
    exports.CFG_NETWORK_CA,
    exports.CFG_NETWORK_CA_FILE,
    exports.CFG_NETWORK_STRICT_SSL,
    exports.CFG_NETWORK_CERT,
    exports.CFG_NETWORK_KEY,
];
const DEFAULT_LINK = "bit";
const DEFAULT_ALTERNATIVE_LINK = "bbit";
const ALTERNATIVE_LINK_WARNING = `A legacy version of Bit is installed on your machine.
Use the 'bbit' command for Bit's latest version and the 'bit' command for Bit's legacy version.
For more information, see the following link: https://harmony-docs.bit.dev/introduction/installation`;
const globalDefaults = {
    BVM_DIR: getBvmDirectory(),
    DEFAULT_LINK: DEFAULT_LINK,
};
function getBvmDirectory() {
    const fromEnvVar = process.env[exports.BVM_GLOBALS_DIR_ENV_VARIABLE];
    if (fromEnvVar && typeof fromEnvVar === "string") {
        return fromEnvVar;
    }
    if (exports.IS_WINDOWS && process.env.LOCALAPPDATA) {
        return path_1.default.join(process.env.LOCALAPPDATA, ".bvm");
    }
    return path_1.default.join(user_home_1.default, ".bvm");
}
function getConfigDirectory() {
    return path_1.default.join(getBvmDirectory(), exports.CONFIG_DIR);
}
function getConfigPath() {
    return path_1.default.join(getConfigDirectory(), exports.CONFIG_FILENAME);
}
let configSingleton;
class Config {
    constructor(name, filePath, defaults = {}, _sources = ["env", "file"]) {
        this.name = name;
        this.filePath = filePath;
        let store = new nconf_1.Provider();
        // TODO: implement
        // sources.forEach((source) => {
        //   // TODO: replace this with store.add / store.use (there is some special case with env/argv when using these methods)
        //   switch (source) {
        //     case 'env':
        //       store.env();
        //       break;
        //     case 'argv':
        //       store.argv();
        //       break;
        //     case 'file':
        //       store.add(name, { type: 'file', file: filePath });
        //       break;
        //     default:
        //       break;
        //   }
        // });
        // store.defaults(defaults);
        // store.env().argv().file(name, filePath).defaults(defaults);
        store
            .env({ transform: transformEnvVariable })
            .file(name, filePath)
            .defaults(defaults);
        const fsStore = new nconf_1.Provider().file(name, filePath);
        this.store = store;
        this.fsStore = fsStore;
    }
    static load(newInstance = false, sources = ["env", "file"]) {
        const isBvmCommand = process.argv[1].includes("bvm");
        if (isBvmCommand &&
            (process.argv.includes("--get-yargs-completions") ||
                process.argv.includes("--help"))) {
            // this is a workaround to get the completion and `bvm --help` working.
            // otherwise, the `new Config()` later on, calls `store.env().argv()`, and for some reason,
            // nconf doesn't play nice with yargs
            // @ts-ignore
            return;
        }
        if (!newInstance && configSingleton) {
            return configSingleton;
        }
        const name = CONFIG_KEY_NAME;
        const configPath = getConfigPath();
        if (!fs_extra_1.default.existsSync(configPath)) {
            fs_extra_1.default.ensureDirSync(path_1.default.dirname(configPath));
            const legacyBitExist = checkIfBitLegacyExist();
            let defaultLink = DEFAULT_LINK;
            if (legacyBitExist) {
                console.log(chalk_1.default.yellowBright(ALTERNATIVE_LINK_WARNING));
                defaultLink = DEFAULT_ALTERNATIVE_LINK;
            }
            fs_extra_1.default.writeJSONSync(configPath, { DEFAULT_LINK: defaultLink });
        }
        const config = new Config(name, configPath, globalDefaults, sources);
        if (!newInstance) {
            configSingleton = config;
        }
        return config;
    }
    get(key) {
        return this.store.get(key);
    }
    set(key, value) {
        this.fsStore.set(key, value);
        this.store.set(key, value);
        this.persist();
    }
    persist() {
        this.fsStore.save(this.name);
    }
    del(key) {
        this.fsStore.clear(key);
        this.store.clear(key);
        this.persist();
    }
    list(persistedOnly = false) {
        const allConfigs = persistedOnly ? this.fsStore.load() : this.store.load();
        return (0, lodash_pickby_1.default)(allConfigs, (val, key) => {
            return (exports.KNOWN_KEYS.includes(key) ||
                key.startsWith(exports.ALIASES_KEY) ||
                key.startsWith(exports.LINKS_KEY));
        });
    }
    path() {
        return this.filePath;
    }
    getBvmDirectory() {
        return this.store.get("BVM_DIR");
    }
    getTempDir() {
        return path_1.default.join(this.getBvmDirectory(), "temp");
    }
    getDefaultLinkName() {
        return this.store.get("DEFAULT_LINK");
    }
    getExtractMethod() {
        return this.store.get(exports.CFG_EXTRACT_METHOD);
    }
    getSkipTempDir() {
        const skipTempDir = this.store.get(exports.CFG_SKIP_TEMP_DIR);
        return skipTempDir === "true" || skipTempDir === true;
    }
    getBitVersionsDir() {
        return path_1.default.join(this.getBvmDirectory(), exports.BIT_VERSIONS_FOLDER_NAME);
    }
    getSpecificVersionDir(version, innerDir = false) {
        const versionsDir = this.getBitVersionsDir();
        let versionDir = path_1.default.join(versionsDir, version);
        if (innerDir) {
            versionDir = path_1.default.join(versionDir, `bit-${version}`);
        }
        const exists = fs_extra_1.default.pathExistsSync(versionDir);
        return {
            versionDir,
            exists,
        };
    }
    getNodeVersionsDir() {
        return path_1.default.join(this.getBvmDirectory(), exports.NODE_VERSIONS_FOLDER_NAME);
    }
    getSpecificNodeVersionDir(version) {
        const versionsDir = this.getNodeVersionsDir();
        const versionDir = path_1.default.join(versionsDir, version);
        const exists = fs_extra_1.default.pathExistsSync(versionDir);
        return {
            versionDir,
            exists,
        };
    }
    /**
     * Returns the Node.js version which is required by the given Bit CLI.
     */
    getWantedNodeVersion(innerVersionDir) {
        const bitManifest = fs_extra_1.default.readJsonSync(path_1.default.join(innerVersionDir, "node_modules/@teambit/bit/package.json"));
        return bitManifest.bvm && bitManifest.bvm.node;
    }
    /**
     * We use a pnpm component for downloading Node.js.
     * pnpm writes the Node.js files to a content-addressable store.
     * We could use pnpm's global store location as well but its location may vary on different systems.
     * So we just create a dedicated content-addressable store for Node.js artifacts in the bvm directory.
     */
    getCafsDir() {
        return path_1.default.join(this.getNodeVersionsDir(), ".store");
    }
    getAliases() {
        const all = this.list();
        const flatAliases = (0, lodash_pickby_1.default)(all, (val, key) => {
            return key.startsWith(exports.ALIASES_KEY);
        });
        const res = Object.keys(flatAliases).reduce((acc, keyName) => {
            const keyWithoutPrefix = keyName.replace(`${exports.ALIASES_KEY}.`, "");
            acc[keyWithoutPrefix] = flatAliases[keyName];
            return acc;
        }, {});
        return res;
    }
    getLinks() {
        const all = this.list();
        const flatLinks = (0, lodash_pickby_1.default)(all, (val, key) => {
            return key.startsWith(exports.LINKS_KEY);
        });
        const res = Object.keys(flatLinks).reduce((acc, keyName) => {
            const keyWithoutPrefix = keyName.replace(`${exports.LINKS_KEY}.`, "");
            acc[keyWithoutPrefix] = flatLinks[keyName];
            return acc;
        }, {});
        return res;
    }
    getReleaseType() {
        return this.get(exports.CFG_RELEASE_TYPE);
    }
    setLink(linkName, value) {
        const keyName = `${exports.LINKS_KEY}.${linkName}`;
        const previousLinkVersion = this.get(keyName);
        this.set(keyName, value);
        return previousLinkVersion;
    }
    getDefaultLinkVersion() {
        const allLinks = this.getLinks();
        const defaultLinkName = this.getDefaultLinkName();
        return allLinks[defaultLinkName];
    }
    networkConfig() {
        var _a, _b, _c, _d, _e;
        const strictSslConfig = (_a = this.get(exports.CFG_NETWORK_STRICT_SSL)) !== null && _a !== void 0 ? _a : this.get(exports.CFG_PROXY_STRICT_SSL);
        const strictSSL = strictSslConfig && typeof strictSslConfig === "string"
            ? strictSslConfig === "true"
            : strictSslConfig;
        return {
            ca: (_b = this.get(exports.CFG_NETWORK_CA)) !== null && _b !== void 0 ? _b : this.get(exports.CFG_PROXY_CA),
            cafile: (_c = this.get(exports.CFG_NETWORK_CA_FILE)) !== null && _c !== void 0 ? _c : this.get(exports.CFG_PROXY_CA_FILE),
            cert: (_d = this.get(exports.CFG_NETWORK_CERT)) !== null && _d !== void 0 ? _d : this.get(exports.CFG_PROXY_CERT),
            key: (_e = this.get(exports.CFG_NETWORK_KEY)) !== null && _e !== void 0 ? _e : this.get(exports.CFG_PROXY_KEY),
            localAddress: this.get(exports.CFG_NETWORK_LOCAL_ADDRESS),
            maxSockets: this.get(exports.CFG_NETWORK_MAX_SOCKETS),
            strictSSL,
        };
    }
    gcpConfig() {
        return {
            accessKey: this.get(exports.CFG_GCP_ACCESS_KEY),
            secretKey: this.get(exports.CFG_GCP_SECRET_KEY),
        };
    }
    proxyConfig() {
        var _a;
        const httpProxy = this.get(exports.CFG_PROXY);
        const httpsProxy = (_a = this.get(exports.CFG_HTTPS_PROXY)) !== null && _a !== void 0 ? _a : this.get(exports.CFG_PROXY);
        // If check is true, return the proxy config only case there is actual proxy server defined
        if (!httpProxy && !httpsProxy)
            return {};
        let noProxy = this.get(exports.CFG_PROXY_NO_PROXY);
        if (noProxy && typeof noProxy === "string") {
            if (noProxy === "true") {
                noProxy = true;
            }
            else if (noProxy === "false") {
                noProxy = false;
            }
        }
        return {
            httpProxy,
            httpsProxy,
            noProxy,
        };
    }
}
exports.Config = Config;
function checkIfBitLegacyExist() {
    try {
        // Ignore errors to prevent printing the error to the console. in case of error we just treat it as it doesn't exists
        const output = (0, child_process_1.execSync)("bit -v", {
            stdio: ["pipe", "pipe", "ignore"],
        }).toString();
        if (output && semver_1.default.valid(output.trim()) && output.startsWith("14")) {
            return true;
        }
        return false;
    }
    catch (e) {
        return false;
    }
}
/**
 * This function will transform the env variable to only get env variable starts with the BVM_ENV_VARS_PREFIX
 * it will also remove this prefix from the env var name so we don't need to treat it with this prefix
 * in rest of the code
 *
 * @param param0
 * @returns
 */
function transformEnvVariable({ key, value, }) {
    if (!key.startsWith(exports.BVM_ENV_VARS_PREFIX)) {
        return undefined;
    }
    if (key === exports.CFG_BVM_DIR) {
        // do not remove BVM_ prefix from the BVM dir config, as this is it's name
        return { key, value };
    }
    return {
        key: key.replace(exports.BVM_ENV_VARS_PREFIX, ""),
        value,
    };
}
//# sourceMappingURL=config.js.map