"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GcpList = exports.ReleaseType = exports.ReleaseTypeFilter = void 0;
const gcp_storage_1 = require("@teambit/gcp.storage");
const toolbox_network_agent_1 = require("@teambit/toolbox.network.agent");
const semver_1 = require("semver");
const node_fetch_1 = __importDefault(require("node-fetch"));
const gcp_version_1 = require("./gcp-version");
const version_list_1 = require("../version-list");
const BIT_INDEX_JSON_OBJECT = 'bit/index.json';
// const BIT_INDEX_JSON_OBJECT = 'bit/index-test.json';
const BIT_INDEX_JSON = `https://bvm.bit.dev/${BIT_INDEX_JSON_OBJECT}`;
const bucketName = 'bvm.bit.dev';
const prefix = 'versions';
var ReleaseTypeFilter;
(function (ReleaseTypeFilter) {
    ReleaseTypeFilter["NIGHTLY_FROM_OLD_LOCATION"] = "nightly-from-old-location";
    // TODO: merge this with the ReleaseType properly
    ReleaseTypeFilter["DEV"] = "dev";
    ReleaseTypeFilter["NIGHTLY"] = "nightly";
    ReleaseTypeFilter["STABLE"] = "stable";
    ReleaseTypeFilter["ALL"] = "all";
})(ReleaseTypeFilter = exports.ReleaseTypeFilter || (exports.ReleaseTypeFilter = {}));
var ReleaseType;
(function (ReleaseType) {
    ReleaseType["DEV"] = "dev";
    ReleaseType["NIGHTLY"] = "nightly";
    ReleaseType["STABLE"] = "stable";
})(ReleaseType = exports.ReleaseType || (exports.ReleaseType = {}));
class GcpList {
    constructor(gcpStorage, proxyConfig = {}, osType = 'Darwin', arch = 'x64', releaseTypeFilter = ReleaseTypeFilter.STABLE) {
        this.gcpStorage = gcpStorage;
        this.proxyConfig = proxyConfig;
        this.osType = osType;
        this.arch = arch;
        this.releaseTypeFilter = releaseTypeFilter;
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.releaseTypeFilter !== ReleaseTypeFilter.NIGHTLY_FROM_OLD_LOCATION) {
                const releases = yield this.fetchIndex();
                const filteredReleases = this.releaseTypeFilter === ReleaseTypeFilter.ALL
                    ? releases
                    : releases.filter((release) => release[this.releaseTypeFilter] === true);
                const remoteVersions = filteredReleases.map((release) => this._createRemoteVersion(release));
                return new version_list_1.RemoteVersionList(remoteVersions);
            }
            const files = (yield this.rawFiles()).filter(file => file.contentType === 'application/x-tar');
            const remoteVersions = files.map((file) => {
                const gcpVersion = new gcp_version_1.GcpVersion(getVersionFromFileName(file.name), file.name, file.bucket, file.md5Hash, file.timeCreated, file.metadata, undefined);
                return gcpVersion.toRemoteVersion();
            });
            return new version_list_1.RemoteVersionList(remoteVersions);
        });
    }
    getIndexJsonUrl() {
        const random = Math.floor(Math.random() * 10000000);
        return `${BIT_INDEX_JSON}?random=${random}`;
    }
    fetchIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.getIndexJsonUrl();
            const response = yield (0, node_fetch_1.default)(url, {
                agent: (0, toolbox_network_agent_1.getAgent)(url, this.proxyConfig),
            });
            return yield response.json();
        });
    }
    updateReleaseEntry(version, releaseTypeUpdates) {
        return __awaiter(this, void 0, void 0, function* () {
            const index = yield this.fetchIndex();
            const release = index.find((release) => release.version === version);
            if (!release) {
                throw new Error(`version ${version} not found in index.json`);
            }
            Object.entries(releaseTypeUpdates).forEach(([releaseType, value]) => {
                if (value) {
                    release[releaseType] = value;
                }
                else {
                    delete release[releaseType];
                }
            });
            const newIndex = index.filter((release) => release.version !== version);
            newIndex.push(release);
            const sortedIndex = newIndex.sort(compareReleases);
            const metadata = {
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache',
            };
            yield this.gcpStorage.putFile(BIT_INDEX_JSON_OBJECT, JSON.stringify(sortedIndex, null, 2), metadata);
            return release;
        });
    }
    _createRemoteVersion(release) {
        const fileName = `bit/versions/${release.version}/bit-${release.version}-${this.osType}-${this.arch}.tar.gz`;
        const releaseType = release[ReleaseType.STABLE] ? ReleaseType.STABLE : ReleaseType.NIGHTLY;
        const gcpVersion = new gcp_version_1.GcpVersion(release.version, fileName, bucketName, '', release.date, {}, undefined, releaseType);
        return gcpVersion.toRemoteVersion();
    }
    rawFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            // The old location names were capitalized, so we need to get them as well
            // The old name of win was Windows_NT
            const osType = this.osType === 'win' ? 'Windows_NT' : this.osType.charAt(0).toUpperCase() + this.osType.slice(1);
            let filesPrefix = `${prefix}/dev/${this.osType}/`;
            if ((osType === 'Darwin' || osType === 'Linux') && this.arch === 'arm64') {
                filesPrefix = `${prefix}/dev/${osType}-${this.arch}/`;
            }
            return this.gcpStorage.getFiles({ prefix: filesPrefix });
        });
    }
    static create(releaseTypeFilter = ReleaseTypeFilter.STABLE, osType = 'darwin', arch = 'x64', proxyConfig, accessKey, secretKey) {
        const gcpStorage = gcp_storage_1.GcpStorage.create(bucketName, proxyConfig, accessKey, secretKey);
        return new GcpList(gcpStorage, proxyConfig, osType, arch, releaseTypeFilter);
    }
}
exports.GcpList = GcpList;
function getVersionFromFileName(fileName) {
    return fileName
        .split('/')[4]
        .replace(/\.[^/.]+$/, '')
        .replace(/\.[^/.]+$/, '')
        .split('-')[1];
}
function compareReleases(v1, v2) {
    try {
        return (0, semver_1.compare)(v1.version, v2.version);
    }
    catch (err) {
        // in case one of them is a snap
        return 0;
    }
}
//# sourceMappingURL=gcp-list.js.map