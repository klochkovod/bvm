"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installVersion = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const fetch_1 = require("@pnpm/fetch");
const node_fetcher_1 = require("@pnpm/node.fetcher");
const bvm_fetch_1 = require("@teambit/bvm.fetch");
const toolbox_fs_progress_bar_file_extractor_1 = require("@teambit/toolbox.fs.progress-bar-file-extractor");
const ora_1 = __importDefault(require("ora"));
const toolbox_time_time_format_1 = require("@teambit/toolbox.time.time-format");
const bvm_config_1 = require("@teambit/bvm.config");
const bvm_error_1 = require("@teambit/bvm.error");
const bvm_link_1 = require("@teambit/bvm.link");
const bvm_list_1 = require("@teambit/bvm.list");
const bvm_fs_tar_version_1 = require("@teambit/bvm.fs-tar-version");
const defaultOpts = {
    override: false,
    replace: false
};
const OS_DEFAULT_EXTRACT_METHOD = {
    'linux': 'default',
    'win': 'child-process',
    'darwin': 'default'
};
const loader = (0, ora_1.default)();
function installVersion(version, opts = defaultOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        const concreteOpts = Object.assign({}, defaultOpts, opts);
        const config = getConfig();
        let resolvedVersion = version;
        if (!version || version === 'latest') {
            if (opts.file) {
                const versionFromFileName = getBitVersionFromFilePath(opts.file);
                if (!versionFromFileName) {
                    throw new bvm_error_1.BvmError(`Could not detect bit version from file name "${opts.file}"`);
                }
                resolvedVersion = versionFromFileName;
            }
            else {
                const remoteVersionList = yield (0, bvm_list_1.listRemote)({ os: opts.os, arch: opts.arch });
                resolvedVersion = remoteVersionList.latest().version;
            }
        }
        const { versionDir, exists } = config.getSpecificVersionDir(resolvedVersion);
        const skipTempDir = config.getSkipTempDir();
        const extractDir = skipTempDir ? versionDir : undefined;
        if (exists) {
            if (!concreteOpts.override) {
                const replacedCurrentResult = yield replaceCurrentIfNeeded(concreteOpts.replace, resolvedVersion, {
                    addToPathIfMissing: opts.addToPathIfMissing,
                    useSystemNode: opts.useSystemNode,
                });
                return {
                    downloadRequired: false,
                    installedVersion: resolvedVersion,
                    replacedCurrent: replacedCurrentResult.replaced,
                    previousCurrentVersion: replacedCurrentResult.previousCurrentVersion,
                    pathExtenderReport: replacedCurrentResult.pathExtenderReport,
                    warnings: replacedCurrentResult.warnings,
                    versionPath: versionDir
                };
            }
            yield removeWithLoader(versionDir);
        }
        const tempDir = config.getTempDir();
        let fsTarVersion;
        if (opts.file) {
            fsTarVersion = new bvm_fs_tar_version_1.FsTarVersion(opts.file);
            fsTarVersion = yield fsTarVersion.copyToDir(tempDir, { loader });
        }
        else {
            const fetchOpts = {
                overrideDir: true,
                destinationDir: tempDir,
                os: opts.os,
                arch: opts.arch
            };
            fsTarVersion = yield (0, bvm_fetch_1.fetch)(resolvedVersion, fetchOpts);
            // TODO: check if version already exists, return it's location
        }
        if (fsTarVersion.path) {
            const tarFile = fsTarVersion.path;
            const extractMethod = getExtractMethod(opts.extractMethod, opts.os);
            if (!extractMethod || extractMethod === 'default') {
                yield extractWithLoader(fsTarVersion.path, fsTarVersion.version, extractDir);
            }
            else {
                const extractFlags = ['-xf', path_1.default.basename(fsTarVersion.path)];
                if (extractDir) {
                    fs_extra_1.default.ensureDir(extractDir);
                    extractFlags.push('-C', extractDir);
                }
                const extractMsg = `extracting version ${fsTarVersion.version} using ${extractMethod} method`;
                loader.start(extractMsg);
                const extractStartTime = Date.now();
                try {
                    /* Extracting the tar file. */
                    yield (0, execa_1.default)('tar', extractFlags, { cwd: tempDir });
                    const extractEndTime = Date.now();
                    const extractTimeDiff = (0, toolbox_time_time_format_1.timeFormat)(extractEndTime - extractStartTime);
                    loader.succeed(`extracting version ${fsTarVersion.version} in ${extractTimeDiff}`);
                }
                catch (e) {
                    console.log('failed to extract, error: ', e.message || '');
                    throw (e);
                }
            }
            yield removeWithLoader(tarFile);
        }
        if (!extractDir) {
            yield moveWithLoader(tempDir, versionDir, { overwrite: true });
        }
        let useSystemNode = opts.useSystemNode;
        if (!useSystemNode) {
            const wantedNodeVersion = config.getWantedNodeVersion(path_1.default.join(versionDir, `bit-${resolvedVersion}`));
            if (wantedNodeVersion) {
                // If Node.js installation doesn't succeed, we'll use the system default Node.js instead.
                useSystemNode = !(yield installNode(config, wantedNodeVersion));
            }
        }
        const replacedCurrentResult = yield replaceCurrentIfNeeded(concreteOpts.replace, fsTarVersion.version, {
            addToPathIfMissing: opts.addToPathIfMissing,
            useSystemNode,
        });
        loader.stop();
        return {
            downloadRequired: !!fsTarVersion.path,
            installedVersion: fsTarVersion.version,
            replacedCurrent: replacedCurrentResult.replaced,
            previousCurrentVersion: replacedCurrentResult.previousCurrentVersion,
            pathExtenderReport: replacedCurrentResult.pathExtenderReport,
            warnings: replacedCurrentResult.warnings,
            versionPath: versionDir
        };
    });
}
exports.installVersion = installVersion;
function getExtractMethod(extractMethod, osName) {
    const validExtractMethods = ['default', 'child-process'];
    const extractMethodOrFromConfig = extractMethod || getConfig().getExtractMethod();
    if (extractMethodOrFromConfig && validExtractMethods.includes(extractMethodOrFromConfig)) {
        return extractMethodOrFromConfig;
    }
    const osType = (0, bvm_list_1.getOsType)(osName);
    return (OS_DEFAULT_EXTRACT_METHOD[osType] || 'default');
}
/*
 * Reads Bit's version from a tarball filename like "bit-0.0.778-linux-x64.tar.gz"
 * Returns null if a version is not found.
 */
function getBitVersionFromFilePath(filePath) {
    const fileName = path_1.default.basename(filePath);
    const parts = fileName.split('-');
    if (parts.length < 4)
        return null;
    const versionParts = parts.slice(1, parts.length - 2);
    const version = versionParts.join('');
    if (!semver_1.default.valid(version))
        return null;
    return version;
}
/**
 * Install the given Node.js version to the bvm directory if it is wasn't installed yet.
 */
function installNode(config, version) {
    return __awaiter(this, void 0, void 0, function* () {
        const { versionDir, exists } = config.getSpecificNodeVersionDir(version);
        if (exists)
            return versionDir;
        const networkConfig = config.networkConfig();
        const fetch = (0, fetch_1.createFetchFromRegistry)(Object.assign(Object.assign(Object.assign({}, networkConfig), config.proxyConfig()), { strictSsl: networkConfig.strictSSL }));
        const cafsDir = config.getCafsDir();
        const loaderText = `downloading Node.js ${version}`;
        loader.start(loaderText);
        try {
            yield (0, node_fetcher_1.fetchNode)(fetch, version, versionDir, { cafsDir });
        }
        catch (err) {
            loader.fail('Could not install Node.js, using the system Node.js instead');
            return undefined;
        }
        loader.succeed(loaderText);
        return versionDir;
    });
}
function extractWithLoader(filePath, version, targetDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const extractLoaderText = `extracting version ${version}`;
        const extractStartTime = Date.now();
        const progressBarOpts = {
            format: `extracting version ${version} [{bar}] {percentage}% | ETA: {etah} | Speed: {speed}`,
        };
        yield (0, toolbox_fs_progress_bar_file_extractor_1.extract)(filePath, targetDir, { ensureDir: true }, progressBarOpts);
        const extractEndTime = Date.now();
        const extractTimeDiff = (0, toolbox_time_time_format_1.timeFormat)(extractEndTime - extractStartTime);
        loader.succeed(`${extractLoaderText} in ${extractTimeDiff}`);
    });
}
function removeWithLoader(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const removeLoaderText = `removing ${filePath}`;
        loader.start(removeLoaderText);
        const removeStartTime = Date.now();
        yield fs_extra_1.default.remove(filePath);
        const removeEndTime = Date.now();
        const removeTimeDiff = (0, toolbox_time_time_format_1.timeFormat)(removeEndTime - removeStartTime);
        loader.succeed(`${removeLoaderText} in ${removeTimeDiff}`);
    });
}
function moveWithLoader(src, target, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const moveLoaderText = `moving from temp folder to final location`;
        loader.start(moveLoaderText);
        const moveStartTime = Date.now();
        yield fs_extra_1.default.move(src, target, opts);
        const moveEndTime = Date.now();
        const moveTimeDiff = (0, toolbox_time_time_format_1.timeFormat)(moveEndTime - moveStartTime);
        loader.succeed(`${moveLoaderText} in ${moveTimeDiff}`);
    });
}
function replaceCurrentIfNeeded(forceReplace, version, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = getConfig();
        const currentLink = config.getDefaultLinkVersion();
        if (forceReplace || !currentLink) {
            const { previousLinkVersion, pathExtenderReport, warnings } = yield (0, bvm_link_1.linkOne)(config.getDefaultLinkName(), version, {
                addToConfig: true,
                addToPathIfMissing: opts.addToPathIfMissing,
                useSystemNode: opts.useSystemNode,
            });
            return {
                replaced: true,
                previousCurrentVersion: previousLinkVersion,
                pathExtenderReport,
                warnings,
            };
        }
        return {
            replaced: false
        };
    });
}
function getConfig() {
    const config = bvm_config_1.Config.load();
    return config;
}
//# sourceMappingURL=install.js.map